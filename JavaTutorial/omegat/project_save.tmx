<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE tmx SYSTEM "tmx11.dtd">
<tmx version="1.1">
  <header creationtool="OmegaT" o-tmf="OmegaT TMX" adminlang="EN-US" datatype="plaintext" creationtoolversion="OmegaT-3.6.0" segtype="sentence" srclang="EN-US"/>
  <body>
<!-- Default translations -->
    <tu>
      <tuv lang="EN-US">
        <seg>(An important exception: &lt;c1&gt;final&lt;/c1&gt; fields, which cannot be modified after the object is constructed, can be safely read through non-synchronized methods, once the object is constructed) This strategy is effective, but can present problems with &lt;a2&gt;liveness&lt;/a2&gt;, as we'll see later in this lesson.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T103124Z" creationid="Admin" creationdate="20170622T103124Z">
        <seg>（一个重要的例外是：&lt;c1&gt;final&lt;/c1&gt; 字段，它在对象创建完成后是不能被修改的，因此，一旦对象创建完毕，就可以通过非同步的方法对其进行安全的读取）。这种策略是有效的，但是可能导致 &lt;a2&gt;活跃度（liveness）&lt;/a2&gt;问题。这点我们会在本课程的后面进行描述。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Invoking other objects' methods from synchronized code can create problems that are described in the section on &lt;a3&gt;Liveness&lt;/a3&gt;.) Without synchronized statements, there would have to be a separate, unsynchronized method for the sole purpose of invoking &lt;c4&gt;nameList.add&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T065309Z" creationid="Admin" creationdate="20170623T064853Z">
        <seg>（在同步代码中调用其他对象的方法可能导致问题，将在&lt;a3&gt;Liveness&lt;/a3&gt;部分描述。）如果没有使用同步语名块，那么将不得不使用一个单独的，未同步的方法来完成对&lt;c4&gt;nameList.add&lt;/c4&gt;的调用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The API specification often refers to this entity simply as a "monitor.") Intrinsic locks play a role in both aspects of synchronization: enforcing exclusive access to an object's state and establishing happens-before relationships that are essential to visibility.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T062755Z" creationid="Admin" creationdate="20170623T062340Z">
        <seg>（API 规范通常将此实体简称为“监视器（monitor）”。）内部锁在同步的两个方面发挥作用：强制对对象状态的独占（独占，排他，exclusive）访问，并建立对对象可见性至关重要的happens-before关系。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(We'll describe worker threads in the section on &lt;a5&gt;Thread Pools&lt;/a5&gt;.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T032029Z" creationid="Admin" creationdate="20170630T032029Z">
        <seg>（我们将在&lt;a5&gt;线程池&lt;/a5&gt;一节中描述工作线程。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;a0&gt;&lt;c1&gt;BlockingQueue&lt;/c1&gt;&lt;/a0&gt; defines a first-in-first-out data structure that blocks or times out when you attempt to add to a full queue, or retrieve from an empty queue.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T072046Z" creationid="Admin" creationdate="20170630T072046Z">
        <seg>&lt;a0&gt;&lt;c1&gt;BlockingQueue&lt;/c1&gt;&lt;/a0&gt;定义了一个先进先出的数据结构，当你尝试往满队列中添加元素，或者从空队列中获取元素时，将会阻塞或者超时。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;a0&gt;&lt;c1&gt;ConcurrentMap&lt;/c1&gt;&lt;/a0&gt; is a subinterface of &lt;a2&gt;&lt;c3&gt;java.util.Map&lt;/c3&gt;&lt;/a2&gt; that defines useful atomic operations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T072110Z" creationid="Admin" creationdate="20170630T072110Z">
        <seg>&lt;a0&gt;&lt;c1&gt;ConcurrentMap&lt;/c1&gt;&lt;/a0&gt; 是 &lt;a2&gt;&lt;c3&gt;java.util.Map&lt;/c3&gt;&lt;/a2&gt; 的子接口，定义了一些有用的原子操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;a0&gt;&lt;c1&gt;ConcurrentNavigableMap&lt;/c1&gt;&lt;/a0&gt; is a subinterface of &lt;c2&gt;ConcurrentMap&lt;/c2&gt; that supports approximate matches.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T072350Z" creationid="Admin" creationdate="20170630T072350Z">
        <seg>&lt;a0&gt;&lt;c1&gt;ConcurrentNavigableMap&lt;/c1&gt;&lt;/a0&gt; 是 &lt;c2&gt;ConcurrentMap&lt;/c2&gt; 的子接口，支持近似匹配。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;a0&gt;&lt;c1&gt;SimpleThreads&lt;/c1&gt;&lt;/a0&gt; consists of two threads.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T080347Z" creationid="Admin" creationdate="20170622T080347Z">
        <seg>&lt;a0&gt;&lt;c1&gt;SimpleThreads&lt;/c1&gt;&lt;/a0&gt; 由两个线程组成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;a0&gt;&lt;c1&gt;ThreadLocalRandom&lt;/c1&gt;&lt;/a0&gt; (in JDK 7) provides efficient generation of pseudorandom numbers from multiple threads.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T023747Z" creationid="Admin" creationdate="20170630T023747Z">
        <seg>&lt;a0&gt;&lt;c1&gt;并发随机数（ThreadLocalRandom）&lt;/c1&gt;&lt;/a0&gt; (in JDK 7) 提供了高效的多线程生成伪随机数的方法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;a0&gt;Atomic Access&lt;/a0&gt; talks about the general idea of operations that can't be interfered with by other threads.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T084138Z" creationid="Admin" creationdate="20170622T084138Z">
        <seg>&lt;a0&gt;原子访问（Atomic Access）&lt;/a0&gt;谈到不受其他线程干扰的操作的一般思路。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;a0&gt;Atomic variables&lt;/a0&gt; have features that minimize synchronization and help avoid memory consistency errors.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T023636Z" creationid="Admin" creationdate="20170630T023636Z">
        <seg>&lt;a0&gt;原子变量&lt;/a0&gt; 具有最小化同步并有助于避免内存一致性错误的功能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;a0&gt;Concurrent collections&lt;/a0&gt; make it easier to manage large collections of data, and can greatly reduce the need for synchronization.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T023518Z" creationid="Admin" creationdate="20170630T023518Z">
        <seg>&lt;a0&gt;并发集合&lt;/a0&gt; 并发集合简化了大型数据集合管理，且极大的减少了同步的需求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;a0&gt;Executor Interfaces&lt;/a0&gt; define the three executor object types.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T030027Z" creationid="Admin" creationdate="20170630T030027Z">
        <seg>&lt;a0&gt;执行器接口&lt;/a0&gt; 定义三个执行器对象类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;a0&gt;Executors&lt;/a0&gt; define a high-level API for launching and managing threads.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T023344Z" creationid="Admin" creationdate="20170630T023344Z">
        <seg>&lt;a0&gt;执行器（Executors）&lt;/a0&gt; 定义一个用于启动和管理线程的高级API。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;a0&gt;Fork/Join&lt;/a0&gt; is a framework (new in JDK 7) for taking advantage of multiple processors.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T030222Z" creationid="Admin" creationdate="20170630T030222Z">
        <seg>&lt;a0&gt;Fork/Join&lt;/a0&gt; 是一个框架（JDK 7中新添加），目的是为了帮助你更好地利用多处理器带来的好处。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;a0&gt;Home Page&lt;/a0&gt; &gt; &lt;a1&gt;Essential Classes&lt;/a1&gt;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T080230Z" creationid="Admin" creationdate="20170630T080230Z">
        <seg>&lt;a0&gt;首页&lt;/a0&gt; &gt; &lt;a1&gt;基本类&lt;/a1&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;a0&gt;Home Page&lt;/a0&gt; &gt; &lt;a1&gt;Essential Classes&lt;/a1&gt; &gt; &lt;a2&gt;Concurrency&lt;/a2&gt;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T080630Z" creationid="Admin" creationdate="20170630T080630Z">
        <seg>&lt;a0&gt;主页&lt;/a0&gt; &gt; &lt;a1&gt;基本类&lt;/a1&gt; &gt; &lt;a2&gt;并发&lt;/a2&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;a0&gt;Implicit Locks and Synchronization&lt;/a0&gt; describes a more general synchronization idiom, and describes how synchronization is based on implicit locks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T103410Z" creationid="Admin" creationdate="20170622T084045Z">
        <seg>&lt;a0&gt;隐式锁（内部锁：intrinsic ）和同步（Implicit Locks and Synchronization）&lt;/a0&gt;描述了一个更一般的同步做法，并描述了如何基于隐式锁的同步。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;a0&gt;Lock objects&lt;/a0&gt; support locking idioms that simplify many concurrent applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T023304Z" creationid="Admin" creationdate="20170630T023304Z">
        <seg>&lt;a0&gt;锁对象&lt;/a0&gt; 提供了可以简化许多并发应用的锁的用法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;a0&gt;Memory Consistency Errors&lt;/a0&gt; describes errors that result from inconsistent views of shared memory.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T083837Z" creationid="Admin" creationdate="20170622T083728Z">
        <seg>&lt;a0&gt;内存一致性错误（Memory Consistency Errors）&lt;/a0&gt;描述由于共享内存视图不一致而导致的错误。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;a0&gt;Synchronized Methods&lt;/a0&gt; describes a simple idiom that can effectively prevent thread interference and memory consistency errors.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T083915Z" creationid="Admin" creationdate="20170622T083825Z">
        <seg>&lt;a0&gt;同步方法（Synchronized Methods）&lt;/a0&gt;描述了一种简单的做法，可以有效防止线程干扰和内存一致性错误。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;a0&gt;Thread Interference&lt;/a0&gt; describes how errors are introduced when multiple threads access shared data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T083833Z" creationid="Admin" creationdate="20170622T083659Z">
        <seg>&lt;a0&gt;线程干扰（Thread Interferenc）&lt;/a0&gt;描述了多线程访问共享数据时如何引入错误。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;a0&gt;Thread Pools&lt;/a0&gt; are the most common kind of executor implementation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T030102Z" creationid="Admin" creationdate="20170630T030102Z">
        <seg>&lt;a0&gt;线程池&lt;/a0&gt; 线程池是最常见的一种执行器的实现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;a0&gt;Your use of this&lt;/a0&gt; page and all the material on pages under "The Java Tutorials" banner is subject to these &lt;a1&gt;legal notices&lt;/a1&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T062353Z" creationid="Admin" creationdate="20170622T062353Z">
        <seg>&lt;a0&gt;您使用这个&lt;/a0&gt;页面及 "The Java Tutorials"banner下的所有村料都受这些&lt;a1&gt;法律申明&lt;/a1&gt;所约束。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;a0&gt;« Previous&lt;/a0&gt; • &lt;a1&gt;Trail&lt;/a1&gt; • &lt;a2&gt;Next »&lt;/a2&gt;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T073829Z" creationid="Admin" creationdate="20170623T073829Z">
        <seg>&lt;a0&gt;« 前&lt;/a0&gt; • &lt;a1&gt;Trail&lt;/a1&gt; • &lt;a2&gt;后 »&lt;/a2&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;a0&gt;« Previous&lt;/a0&gt; • &lt;a1&gt;Trail&lt;/a1&gt; • &lt;a2&gt;Next »&lt;/a2&gt;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T062556Z" creationid="Admin" creationdate="20170622T062556Z">
        <seg>&lt;a0&gt;« 前&lt;/a0&gt; • &lt;a1&gt;Trail&lt;/a1&gt; • &lt;a2&gt;后 »&lt;/a2&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;a3&gt;Starvation and livelock&lt;/a3&gt; are forms of thread contention.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T083526Z" creationid="Admin" creationdate="20170622T083526Z">
        <seg>&lt;a3&gt;饥饿（Starvation）和活锁 （livelock）&lt;/a3&gt; 是线程竞争的表现形式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;b0&gt;Trail:&lt;/b0&gt; Essential Classes</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T080237Z" creationid="Admin" creationdate="20170630T080215Z">
        <seg>&lt;b0&gt;Trail:&lt;/b0&gt;基本类</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;Counter&lt;/c0&gt; is designed so that each invocation of &lt;c1&gt;increment&lt;/c1&gt; will add 1 to &lt;c2&gt;c&lt;/c2&gt;, and each invocation of &lt;c3&gt;decrement&lt;/c3&gt; will subtract 1 from &lt;c4&gt;c&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T084538Z" creationid="Admin" creationdate="20170622T084538Z">
        <seg>&lt;c0&gt;Counter&lt;/c0&gt; 被设计为每次调用 &lt;c1&gt;increment&lt;/c1&gt; 将对 &lt;c2&gt;c&lt;/c2&gt;加1 ，每次调用 &lt;c3&gt;decrement&lt;/c3&gt; 将会对&lt;c4&gt;c&lt;/c4&gt;减1。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;Executor&lt;/c0&gt;, a simple interface that supports launching new tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T030355Z" creationid="Admin" creationdate="20170630T030355Z">
        <seg>&lt;c0&gt;Executor&lt;/c0&gt;，一个运行新任务的简单接口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;ExecutorService&lt;/c0&gt; also provides methods for submitting large collections of &lt;c1&gt;Callable&lt;/c1&gt; objects.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T062748Z" creationid="Admin" creationdate="20170630T062748Z">
        <seg>&lt;c0&gt;ExecutorService&lt;/c0&gt; 也提供了批量运行 &lt;c1&gt;Callable&lt;/c1&gt; 对象的方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;ExecutorService&lt;/c0&gt;, a subinterface of &lt;c1&gt;Executor&lt;/c1&gt;, which adds features that help manage the lifecycle, both of the individual tasks and of the executor itself.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T030505Z" creationid="Admin" creationdate="20170630T030446Z">
        <seg>&lt;c0&gt;ExecutorService&lt;/c0&gt;扩展自&lt;c1&gt;Executor&lt;/c1&gt;，添加了一些用来管理执行器生命周期和任务生命周期的方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;Lock&lt;/c0&gt; objects work very much like the implicit locks used by synchronized code.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T024310Z" creationid="Admin" creationdate="20170630T024310Z">
        <seg>&lt;c0&gt;Lock&lt;/c0&gt; 对象作用非常类似同步代码使用的内部锁（implicit lock）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;ScheduledExecutorService&lt;/c0&gt;, a subinterface of &lt;c1&gt;ExecutorService&lt;/c1&gt;, supports future and/or periodic execution of tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T030604Z" creationid="Admin" creationdate="20170630T030502Z">
        <seg>&lt;c0&gt;ScheduledExecutorService&lt;/c0&gt;扩展自&lt;c1&gt;ExecutorService&lt;/c1&gt;，支持 future 和（或）定期执行任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;SynchronizedRGB&lt;/c0&gt; must be used carefully to avoid being seen in an inconsistent state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T100912Z" creationid="Admin" creationdate="20170623T100912Z">
        <seg>&lt;c0&gt;SynchronizedRGB&lt;/c0&gt; 使用时必须小心，避免其处于不一致的状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;Thread.sleep&lt;/c0&gt; causes the current thread to suspend execution for a specified period.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T070708Z" creationid="Admin" creationdate="20170622T070708Z">
        <seg>&lt;c0&gt;Thread.sleep&lt;/c0&gt; 可以让当前线程执行暂停一个时间段</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c2&gt;Lock&lt;/c2&gt; objects also support a &lt;c3&gt;wait/notify&lt;/c3&gt; mechanism, through their associated &lt;a4&gt;&lt;c5&gt;Condition&lt;/c5&gt;&lt;/a4&gt; objects.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T024442Z" creationid="Admin" creationdate="20170630T024442Z">
        <seg>通过关联的&lt;a4&gt;&lt;c5&gt;Condition&lt;/c5&gt;&lt;/a4&gt; 对象，&lt;c2&gt;Lock&lt;/c2&gt;对象也支持&lt;c3&gt;wait/notify&lt;/c3&gt; 机制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c3&gt;ForkJoinPool&lt;/c3&gt; implements the core work-stealing algorithm and can execute &lt;a4&gt;&lt;c5&gt;ForkJoinTask&lt;/c5&gt;&lt;/a4&gt; processes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T065707Z" creationid="Admin" creationdate="20170630T065707Z">
        <seg>&lt;c3&gt; ForkJoinPool &lt;/c3&gt;实现了核心工作窃取算法，可以执行&lt;a4&gt; &lt;c5&gt; ForkJoinTask &lt;/c5&gt; &lt;/a4&gt;任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;e0&gt;Provide a &lt;c1&gt;Runnable&lt;/c1&gt; object.&lt;/e0&gt; The &lt;a2&gt;&lt;c3&gt;Runnable&lt;/c3&gt;&lt;/a2&gt; interface defines a single method, &lt;c4&gt;run&lt;/c4&gt;, meant to contain the code executed in the thread.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T063138Z" creationid="Admin" creationdate="20170622T063138Z">
        <seg>&lt;e0&gt;提供一个 &lt;c1&gt;Runnable&lt;/c1&gt; 对象。&lt;/e0&gt; &lt;a2&gt;&lt;c3&gt;Runnable&lt;/c3&gt;&lt;/a2&gt; 接口定义了一个简单的方法 &lt;c4&gt;run&lt;/c4&gt;，意味着包含线程中要执行的代码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;e0&gt;Subclass &lt;c1&gt;Thread&lt;/c1&gt;.&lt;/e0&gt; The &lt;c2&gt;Thread&lt;/c2&gt; class itself implements &lt;c3&gt;Runnable&lt;/c3&gt;, though its &lt;c4&gt;run&lt;/c4&gt; method does nothing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T063355Z" creationid="Admin" creationdate="20170622T063355Z">
        <seg>&lt;e0&gt; &lt;c1&gt;Thread&lt;/c1&gt;的子类。&lt;/e0&gt;  &lt;c2&gt;Thread&lt;/c2&gt; 类本身实现了&lt;c3&gt;Runnable&lt;/c3&gt;接口，尽管它的&lt;c4&gt;run&lt;/c4&gt; 方法没做任何操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;i0&gt; &lt;a1&gt;Java Concurrent Animated&lt;/a1&gt;:&lt;/i0&gt; Animations that show usage of concurrency features.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T073810Z" creationid="Admin" creationdate="20170630T073810Z">
        <seg>&lt;i0&gt; &lt;a1&gt; Java并发动画&lt;/a1&gt;：&lt;/i0&gt;显示并发功能使用的动画。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;i0&gt;Deadlock&lt;/i0&gt; describes a situation where two or more threads are blocked forever, waiting for each other.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T074439Z" creationid="Admin" creationdate="20170623T074439Z">
        <seg>&lt;i0&gt;死锁&lt;/i0&gt; 是指两个或两个以上的线程永远被阻塞，一直等待对方的资源的情况。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;i0&gt;Memory consistency errors&lt;/i0&gt; occur when different threads have inconsistent views of what should be the same data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T091522Z" creationid="Admin" creationdate="20170622T091522Z">
        <seg>&lt;i0&gt;内存一致性错误&lt;/i0&gt;发生在不同的线程对本该是相同数据的view不一致时。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;i0&gt;Starvation&lt;/i0&gt; describes a situation where a thread is unable to gain regular access to shared resources and is unable to make progress.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T075905Z" creationid="Admin" creationdate="20170623T075905Z">
        <seg>&lt;i0&gt;饥饿&lt;/i0&gt;描述了这样一种情况：一个线程无法获得对共享资源的定期访问，无法继续执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s0&gt;Note:&lt;/s0&gt; Always invoke &lt;c1&gt;wait&lt;/c1&gt; inside a loop that tests for the condition being waited for.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T091437Z" creationid="Admin" creationdate="20170623T091437Z">
        <seg>&lt;s0&gt;注意：&lt;/s0&gt; 始终在一个检查正在等特的条件的循环内调用 &lt;c1&gt;wait&lt;/c1&gt; 方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s0&gt;Note:&lt;/s0&gt; The &lt;c1&gt;Drop&lt;/c1&gt; class was written in order to demonstrate guarded blocks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T094807Z" creationid="Admin" creationdate="20170623T094807Z">
        <seg>&lt;s0&gt;注意：&lt;/s0&gt;  &lt;c1&gt;Drop&lt;/c1&gt; 类是为了演示保护块而编写的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s0&gt;Note:&lt;/s0&gt; There is a second notification method, &lt;c1&gt;notify&lt;/c1&gt;, which wakes up a single thread.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T092446Z" creationid="Admin" creationdate="20170623T092446Z">
        <seg>&lt;s0&gt;注意：&lt;/s0&gt; 还有第二个通式方法——&lt;c1&gt;notify&lt;/c1&gt;，它只会唤醒一个线程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s0&gt;Warning:&lt;/s0&gt; When constructing an object that will be shared between threads, be very careful that a reference to the object does not "leak" prematurely.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T102334Z" creationid="Admin" creationdate="20170622T102334Z">
        <seg>&lt;s0&gt;警告：&lt;/s0&gt; 在创建多个线程共享的对象时，要特别小心对该对象的引用不能过早地“泄露”。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Java application can create additional processes using a &lt;a0&gt;&lt;c1&gt;ProcessBuilder&lt;/c1&gt;&lt;/a0&gt; object.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T041857Z" creationid="Admin" creationdate="20170622T041857Z">
        <seg>Java 应用程序可以使用&lt;a0&gt;&lt;c1&gt;ProcessBuilder&lt;/c1&gt;&lt;/a0&gt; 对象创建额外的进程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Strategy for Defining Immutable Objects</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T101326Z" creationid="Admin" creationdate="20170623T101326Z">
        <seg>定义不可变对象的策略</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Synchronized Class Example</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T095008Z" creationid="Admin" creationdate="20170623T095008Z">
        <seg>一个同步类的例子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A comprehensive work by a leading expert, who's also the architect of the Java platform's concurrency framework.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T073622Z" creationid="Admin" creationdate="20170630T073622Z">
        <seg>领先专家的全面工作，他也是Java平台并发框架的架构师。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A computer system normally has many active processes and threads.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T034345Z" creationid="Admin" creationdate="20170622T034345Z">
        <seg>一个计算机系统通常有许多活动的进程和线程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A concurrent application's ability to execute in a timely manner is known as its &lt;i0&gt;liveness&lt;/i0&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T074029Z" creationid="Admin" creationdate="20170623T074029Z">
        <seg>一个发行应用程序及时执行的能力被称为其 &lt;i0&gt;活跃度（liveness）&lt;/i0&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A more efficient guard invokes &lt;a0&gt;&lt;c1&gt;Object.wait&lt;/c1&gt;&lt;/a0&gt; to suspend the current thread.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T090658Z" creationid="Admin" creationdate="20170623T090658Z">
        <seg>更高效的保护方法是调用&lt;a0&gt;&lt;c1&gt;Object.wait&lt;/c1&gt;&lt;/a0&gt; 来挂起当前线程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A more sophisticated approach is to make the constructor &lt;c1&gt;private&lt;/c1&gt; and construct instances in factory methods.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170626T022421Z" creationid="Admin" creationdate="20170626T022421Z">
        <seg>更好的方法是将构造函数声明为 &lt;c1&gt;private&lt;/c1&gt;，通过工厂方法创建对象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A practical guide designed to be accessible to the novice.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T073646Z" creationid="Admin" creationdate="20170630T073646Z">
        <seg>一个实用的指南，旨在为新手提供。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A process generally has a complete, private set of basic run-time resources; in particular, each process has its own memory space.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T041559Z" creationid="Admin" creationdate="20170622T041559Z">
        <seg>程通常有一个完整的、私人的基本运行时资源;特别是,每个进程都有其自己的内存空间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A process has a self-contained execution environment.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T041429Z" creationid="Admin" creationdate="20170622T041429Z">
        <seg>进程有一个独立的执行环境。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A simple array length threshold helps determine whether the work is performed or split.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T070934Z" creationid="Admin" creationdate="20170630T070934Z">
        <seg>数组的长度可以作为一个简单的阀值来判断任务是应该直接完成还是应该被拆分。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A simple way to create an executor that uses a fixed thread pool is to invoke the &lt;a0&gt;&lt;c1&gt;newFixedThreadPool&lt;/c1&gt;&lt;/a0&gt; factory method in &lt;a2&gt;&lt;c3&gt;java.util.concurrent.Executors&lt;/c3&gt;&lt;/a2&gt; This class also provides the following factory methods:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T064533Z" creationid="Admin" creationdate="20170630T064533Z">
        <seg>创建一个使用固定大小的线程池的执行器的方法是调用 &lt;a2&gt;&lt;c3&gt;java.util.concurrent.Executors&lt;/c3&gt;&lt;/a2&gt;的&lt;a0&gt;&lt;c1&gt;newFixedThreadPool&lt;/c1&gt;&lt;/a0&gt; 工厂方法。该类还提供以下一些工厂方法：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A strict rule of courtesy is that when you bow to a friend, you must remain bowed until your friend has a chance to return the bow.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T074556Z" creationid="Admin" creationdate="20170623T074556Z">
        <seg>礼貌的一个严格的规则是，当你给一个朋友鞠躬时，你必须保持鞠躬，直到你的朋友鞠躬回给你。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A thread is said to &lt;i2&gt;own&lt;/i2&gt; the intrinsic lock between the time it has acquired the lock and released the lock.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T063230Z" creationid="Admin" creationdate="20170623T063230Z">
        <seg>在线程获取对象的内部锁到释放对象的内部锁的这段时间，我们说该线程&lt;i2&gt;占有&lt;/i2&gt;该对象的内部锁。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A thread often acts in response to the action of another thread.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T081513Z" creationid="Admin" creationdate="20170623T081513Z">
        <seg>线程通常会响应于另一个线程的动作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A thread sends an interrupt by invoking &lt;a0&gt;&lt;c1&gt;interrupt&lt;/c1&gt;&lt;/a0&gt; on the &lt;c2&gt;Thread&lt;/c2&gt; object for the thread to be interrupted.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T073917Z" creationid="Admin" creationdate="20170622T073917Z">
        <seg>线程通过调用&lt;c2&gt;Thread&lt;/c2&gt; 对象的&lt;a0&gt;&lt;c1&gt;interrupt&lt;/c1&gt;&lt;/a0&gt; 方法来发出中断，以使线程中断。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After these changes, we have &lt;a0&gt;&lt;c1&gt;&lt;c2&gt;ImmutableRGB&lt;/c2&gt;&lt;/c1&gt;&lt;/a0&gt;:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170626T030038Z" creationid="Admin" creationdate="20170626T030038Z">
        <seg>经过以上这些修改后，我们得到了&lt;a0&gt;&lt;c1&gt;&lt;c2&gt;ImmutableRGB&lt;/c2&gt;&lt;/c1&gt;&lt;/a0&gt;：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After your &lt;c0&gt;ForkJoinTask&lt;/c0&gt; subclass is ready, create the object that represents all the work to be done and pass it to the &lt;c1&gt;invoke()&lt;/c1&gt; method of a &lt;c2&gt;ForkJoinPool&lt;/c2&gt; instance.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T070216Z" creationid="Admin" creationdate="20170630T070216Z">
        <seg>当你的 &lt;c0&gt;ForkJoinTask&lt;/c0&gt; 子类准备好以后，创建一个代表所有需要完成工作的对象，然后将其作为参数传递给一个&lt;c2&gt;ForkJoinPool&lt;/c2&gt; 实例的 &lt;c1&gt;invoke()&lt;/c1&gt; 方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All classes have &lt;c2&gt;get&lt;/c2&gt; and &lt;c3&gt;set&lt;/c3&gt; methods that work like reads and writes on &lt;c4&gt;volatile&lt;/c4&gt; variables.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T072743Z" creationid="Admin" creationdate="20170630T072743Z">
        <seg>所有的类都提供了 &lt;c2&gt;get&lt;/c2&gt; 和 &lt;c3&gt;set&lt;/c3方法，可以使用它们像读写 &lt;c4&gt;volatile&lt;/c4&gt; 变量一样读写原子类。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All fields are already &lt;c0&gt;private&lt;/c0&gt;; they are further qualified as &lt;c1&gt;final&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170626T024855Z" creationid="Admin" creationdate="20170626T024855Z">
        <seg>所有字段已经是&lt;c0&gt; private &lt;/c0&gt;; 它们被进一步限定为&lt;c1&gt; final &lt;/c1&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All of these collections help avoid &lt;a0&gt;Memory Consistency Errors&lt;/a0&gt; by defining a happens-before relationship between an operation that adds an object to the collection with subsequent operations that access or remove that object.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T072559Z" creationid="Admin" creationdate="20170630T072559Z">
        <seg>所有这些集合，通过在集合里新增对象和访问或移除对象的操作之间，定义一个happens-before 的关系，来帮助程序员避免&lt;a0&gt;内存一致性错误&lt;/a0&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All that is needed is a strategy for avoiding them.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T091902Z" creationid="Admin" creationdate="20170622T091902Z">
        <seg>我们需要的是一种可以避免这种错误的方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All updates of these fields must be synchronized, but there's no reason to prevent an update of c1 from being interleaved with an update of c2  and doing so reduces concurrency by creating unnecessary blocking.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T065644Z" creationid="Admin" creationdate="20170623T065644Z">
        <seg>所有对这两个变量的更新都需要进行同步。但是没有理由阻止对 c1 的更新和对 c2 的更新出现交错——这样做会创建不必要的阻塞，进而降低并发性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All you need to do is call &lt;c0&gt;ThreadLocalRandom.current()&lt;/c0&gt;, then call one of its methods to retrieve a random number.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T073445Z" creationid="Admin" creationdate="20170630T073445Z">
        <seg>你只需调用 &lt;c0&gt;ThreadLocalRandom.current()&lt;/c0&gt;， 然后调用它的其中一个方法去获取一个随机数即可。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Allowing a thread to acquire the same lock more than once enables &lt;i1&gt;reentrant synchronization&lt;/i1&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T071509Z" creationid="Admin" creationdate="20170623T071509Z">
        <seg>允许一个线程能重复获得同一个锁就使得&lt;i1&gt;重入同步（reentrant synchronization）&lt;/i1&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alphonse and Gaston are friends, and great believers in courtesy.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T074511Z" creationid="Admin" creationdate="20170623T074511Z">
        <seg>Alphonse 和 Gaston 是朋友,都很有礼貌。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alphonse and Gaston have trained themselves to notice when a friend is about to bow.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T024730Z" creationid="Admin" creationdate="20170630T024730Z">
        <seg>Alphonse 和 Gaston 已经把自己训练成能注意到朋友何时要鞠躬。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also, the sleep period can be terminated by interrupts, as we'll see in a later section.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T071325Z" creationid="Admin" creationdate="20170622T071325Z">
        <seg>此外，休眠期可以通过中断终止，我们将在后面的部分中看到。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An &lt;i0&gt;interrupt&lt;/i0&gt; is an indication to a thread that it should stop what it is doing and do something else.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T072725Z" creationid="Admin" creationdate="20170622T072621Z">
        <seg>&lt;i0&gt;interrupt&lt;/i0&gt; 是一个线程的指示，告诉它应该停止它正在做的事，去做别的事情。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An application can subclass &lt;c5&gt;Thread&lt;/c5&gt;, providing its own implementation of &lt;c6&gt;run&lt;/c6&gt;, as in the &lt;a7&gt;&lt;c8&gt;&lt;c9&gt;HelloThread&lt;/c9&gt;&lt;/c8&gt;&lt;/a7&gt; example:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T063537Z" creationid="Admin" creationdate="20170622T063537Z">
        <seg>就用可以继承&lt;c5&gt;Thread&lt;/c5&gt;，提供自己的 &lt;c6&gt;run&lt;/c6&gt;实现，如 &lt;a7&gt;&lt;c8&gt;&lt;c9&gt;HelloThread&lt;/c9&gt;&lt;/c8&gt;&lt;/a7&gt; 所示：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An application that creates an instance of &lt;c0&gt;Thread&lt;/c0&gt; must provide the code that will run in that thread.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T062810Z" creationid="Admin" creationdate="20170622T062810Z">
        <seg>创建&lt;c0&gt;Thread&lt;/c0&gt;的实例的应用程序必须提供将在该线程中运行的代码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An atomic action cannot stop in the middle: it either happens completely, or it doesn't happen at all.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T072109Z" creationid="Admin" creationdate="20170623T072109Z">
        <seg>原子性动作是不能在中间停止的：要么一次性完全执行完毕，要么就不执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An important advantage of the fixed thread pool is that applications using it &lt;i0&gt;degrade gracefully&lt;/i0&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T063937Z" creationid="Admin" creationdate="20170630T063937Z">
        <seg>使用固定大小的线程池一个很重要的好处是可以实现 &lt;i0&gt;优雅退化（degrade gracefully）&lt;/i0&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An introduction to concurrent programming through a combination of modeling and practical examples.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T073745Z" creationid="Admin" creationdate="20170630T073745Z">
        <seg>通过建模和实例的组合介绍并发编程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An object is considered &lt;i0&gt;immutable&lt;/i0&gt; if its state cannot change after it is constructed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T095343Z" creationid="Admin" creationdate="20170623T095343Z">
        <seg>如果一个对象被构造后，状态不能改变，则这个对象被认为是&lt;i0&gt;不可变的（immutable）&lt;/i0&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another implementation of the fork/join framework is used by methods in the &lt;c0&gt;java.util.streams&lt;/c0&gt; package, which is part of &lt;a1&gt;Project Lambda&lt;/a1&gt; scheduled for the Java SE 8 release.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T071827Z" creationid="Admin" creationdate="20170630T071827Z">
        <seg>其他采用了 fork/join 框架的方法还包括 &lt;c0&gt;java.util.streams&lt;/c0&gt; 包，此包是作为 java se 8 发行版中  &lt;a1&gt;Project Lambda&lt;/a1&gt; 中的一部分。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another way to create synchronized code is with &lt;i0&gt;synchronized statements&lt;/i0&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T064418Z" creationid="Admin" creationdate="20170623T064418Z">
        <seg>另外一种创建同步代码的方式就是使用 &lt;i0&gt;同步语名块（synchronized statements）&lt;/i0&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Applying this strategy to &lt;c0&gt;SynchronizedRGB&lt;/c0&gt; results in the following steps:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170626T022841Z" creationid="Admin" creationdate="20170626T022841Z">
        <seg>将这一策略应用到&lt;c0&gt;SynchronizedRGB&lt;/c0&gt; 有以下几步：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As long as a thread owns an intrinsic lock, no other thread can acquire the same lock.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T063307Z" creationid="Admin" creationdate="20170623T063307Z">
        <seg>只要有一个线程已经拥有了一个内部锁，其他线程就不能再拥有该锁了。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with any &lt;c0&gt;ExecutorService&lt;/c0&gt; implementation, the fork/join framework distributes tasks to worker threads in a thread pool.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T065305Z" creationid="Admin" creationdate="20170630T065305Z">
        <seg>与任何&lt;c0&gt; ExecutorService &lt;/c0&gt;实现一样，fork/join框架将任务分配给线程池中的工作线程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with deadlock, livelocked threads are unable to make further progress.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T081730Z" creationid="Admin" creationdate="20170623T081730Z">
        <seg>与死锁一样，活锁后线程也无法进一步运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with implicit locks, only one thread can own a &lt;c1&gt;Lock&lt;/c1&gt; object at a time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T024332Z" creationid="Admin" creationdate="20170630T024332Z">
        <seg>如同内部锁，每次只有一个线程可以获得 &lt;c1&gt;Lock&lt;/c1&gt; 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At some future time, another thread will acquire the same lock and invoke &lt;a1&gt;&lt;c2&gt;Object.notifyAll&lt;/c2&gt;&lt;/a1&gt;, informing all threads waiting on that lock that something important has happened:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T092209Z" creationid="Admin" creationdate="20170623T092209Z">
        <seg>然后另一个线程请求该锁并调用 &lt;a1&gt;&lt;c2&gt;Object.notifyAll&lt;/c2&gt;&lt;/a1&gt;，通知所有等待该锁的线程有重要的事情已经发生了。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Atomic Access</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T071911Z" creationid="Admin" creationdate="20170623T071911Z">
        <seg>原子访问</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Atomic Variables</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T072635Z" creationid="Admin" creationdate="20170630T072635Z">
        <seg>原子变量</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Atomic actions cannot be interleaved, so they can be used without fear of thread interference.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T072623Z" creationid="Admin" creationdate="20170623T072623Z">
        <seg>原子性动作是不会出现交错的，因此，使用这些原子性动作时不用考虑线程间的干扰。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Basic Use</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T065714Z" creationid="Admin" creationdate="20170630T065714Z">
        <seg>基本使用方法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because &lt;c2&gt;notify&lt;/c2&gt; doesn't allow you to specify the thread that is woken up, it is useful only in massively parallel applications  that is, programs with a large number of threads, all doing similar chores.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T092730Z" creationid="Admin" creationdate="20170623T092640Z">
        <seg>因为&lt;c2&gt;notify&lt;/c2&gt;不允许你指定被唤醒的线程，它只在大规模并行应用程序中有用？ 也就是说，有大量线程的程序，都做类似的事情。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because they are unpredictable, thread interference bugs can be difficult to detect and fix.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T091223Z" creationid="Admin" creationdate="20170622T091223Z">
        <seg>由于这种“交错”是不可预测的，线程间相互干扰造成的 bug 是很难定位和修改的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Besides using the fork/join framework to implement custom algorithms for tasks to be performed concurrently on a multiprocessor system (such as the &lt;c0&gt;ForkBlur.java&lt;/c0&gt; example in the previous section), there are some generally useful features in Java SE which are already implemented using the fork/join framework.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T071438Z" creationid="Admin" creationdate="20170630T071438Z">
        <seg>除了能够使用 fork/join 框架来实现能够在多处理系统中被并行执行的定制化算法（如前文中的 &lt;c0&gt;ForkBlur.java&lt;/c0&gt;例子），在 java SE 中一些比较常用的功能点也已经使用 fork/join 框架来实现了。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Blurring for Clarity</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T070311Z" creationid="Admin" creationdate="20170630T070257Z">
        <seg>模糊图片的例子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both processes and threads provide an execution environment, but creating a new thread requires fewer resources than creating a new process.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T042037Z" creationid="Admin" creationdate="20170622T042037Z">
        <seg>进程和线程都提供一个执行环境,但创建一个新的线程比创建一个新的进程需要更少的资源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But a thread &lt;i0&gt;can&lt;/i0&gt; acquire a lock that it already owns.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T070346Z" creationid="Admin" creationdate="20170623T070346Z">
        <seg>介是线程 &lt;i0&gt;可以&lt;/i0&gt; 获得自身已经拥有的锁。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But for a more complicated class, we might want to avoid the liveness impact of unnecessary synchronization.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T073033Z" creationid="Admin" creationdate="20170630T073033Z">
        <seg>但是对于更复杂的类，我们可能想要避免不必要同步所带来的活跃度影响。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But from the application programmer's point of view, you start with just one thread, called the &lt;i0&gt;main thread&lt;/i0&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T042251Z" creationid="Admin" creationdate="20170622T042251Z">
        <seg>但从程序员的角度来看,你启动只有一个线程，称为主线程（ &lt;i0&gt;main thread&lt;/i0&gt;）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But if the two statements are executed in separate threads, the value printed out might well be "0", because there's no guarantee that thread A's change to &lt;c0&gt;counter&lt;/c0&gt; will be visible to thread B  unless the programmer has established a happens-before relationship between these two statements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T092429Z" creationid="Admin" creationdate="20170622T092429Z">
        <seg>但是如果这两条语句是在两个不同的线程中，那么输出的结构有可能是0。这是因为没有保证线程 A 对 &lt;c0&gt;counter&lt;/c0&gt; 的修改对线程 B 来说是可见的。除非程序员在这两条语句间建立了一定的 happens-before 关系。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But then other threads can use &lt;c0&gt;instances&lt;/c0&gt; to access the object before construction of the object is complete.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T102540Z" creationid="Admin" creationdate="20170622T102540Z">
        <seg>但是，其他线程可会在该对象的构造完成之前就使用 &lt;c0&gt;instances&lt;/c0&gt; 访问该对象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By convention, a thread that needs exclusive and consistent access to an object's fields has to &lt;i0&gt;acquire&lt;/i0&gt; the object's intrinsic lock before accessing them, and then &lt;i1&gt;release&lt;/i1&gt; the intrinsic lock when it's done with them.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T063106Z" creationid="Admin" creationdate="20170623T062528Z">
        <seg>按照惯例，如果一个线程需要对一个对象的字段进行排他性访问并保持访问时，必须在访问前&lt;i0&gt;获取&lt;/i0&gt;对象的内部锁， 最后 &lt;i1&gt;释放&lt;/i1&gt; 内部锁。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By convention, any method that exits by throwing an &lt;c0&gt;InterruptedException&lt;/c0&gt; clears interrupt status when it does so.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T075341Z" creationid="Admin" creationdate="20170622T075341Z">
        <seg>按照惯例，任何方法因抛出一个 &lt;c0&gt;InterruptedException&lt;/c0&gt;退出都会清除中断状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Can you pass a &lt;c0&gt;Thread&lt;/c0&gt; object to &lt;c1&gt;Executor.execute&lt;/c1&gt;?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T073916Z" creationid="Admin" creationdate="20170630T073916Z">
        <seg>你可以将&lt;c0&gt;线程&lt;/c0&gt;对象传递给&lt;c1&gt; Executor.execute &lt;/c1&gt;吗？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Check your answers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T074219Z" creationid="Admin" creationdate="20170630T074219Z">
        <seg>检查你的答案。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Compile and run &lt;a0&gt;&lt;c1&gt;&lt;c2&gt;BadThreads.java&lt;/c2&gt;&lt;/c1&gt;&lt;/a0&gt;:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T073954Z" creationid="Admin" creationdate="20170630T073954Z">
        <seg>编译并运行 &lt;a0&gt;&lt;c1&gt;&lt;c2&gt;BadThreads.java&lt;/c2&gt;&lt;/c1&gt;&lt;/a0&gt;：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Computer users take it for granted that their systems can do more than one thing at a time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T033848Z" creationid="Admin" creationdate="20170622T032249Z">
        <seg>参考：_waylau.[ Java 编程要点之并发（Concurrency）详解](http://blog.csdn.net/kkkloveyou/article/details/50561269).计算机用户认为他们的系统一次可以做一件以上的事情。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Concurrency</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T080106Z" creationid="Admin" creationdate="20170630T080106Z">
        <seg>并发</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Concurrent Collections</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T071929Z" creationid="Admin" creationdate="20170630T071929Z">
        <seg>并发集合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Concurrent Random Numbers</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T080133Z" creationid="Admin" creationdate="20170630T080133Z">
        <seg>并发随机数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consider a simple class called &lt;a0&gt;&lt;c1&gt;&lt;c2&gt;Counter&lt;/c2&gt;&lt;/c1&gt;&lt;/a0&gt;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T084352Z" creationid="Admin" creationdate="20170622T084352Z">
        <seg>考虑下面的一个简单的类&lt;a0&gt;&lt;c1&gt;&lt;c2&gt;Counter&lt;/c2&gt;&lt;/c1&gt;&lt;/a0&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Coordination is essential: the consumer thread must not attempt to retrieve the data before the producer thread has delivered it, and the producer thread must not attempt to deliver new data if the consumer hasn't retrieved the old data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T093552Z" creationid="Admin" creationdate="20170623T093552Z">
        <seg>协调是至关重要的：消费者线程不得在生产者线程传递之前尝试检索数据，如果消费者没有检索到旧数据，生产者线程不得尝试传递新数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Create a task that represents all of the work to be done.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T071103Z" creationid="Admin" creationdate="20170630T071103Z">
        <seg>创建一个表示所有需要完成工作的任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Create the &lt;c0&gt;ForkJoinPool&lt;/c0&gt; that will run the task.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T071119Z" creationid="Admin" creationdate="20170630T071119Z">
        <seg>创建将要用来执行任务的  &lt;c0&gt;ForkJoinPool&lt;/c0&gt; 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Deadlock</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T074314Z" creationid="Admin" creationdate="20170623T074314Z">
        <seg>死锁（Deadlock）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Defining and Starting a Thread</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T062613Z" creationid="Admin" creationdate="20170622T062613Z">
        <seg>定义和启动一个线程</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Depending on the &lt;c1&gt;Executor&lt;/c1&gt; implementation, &lt;c2&gt;execute&lt;/c2&gt; may do the same thing, but is more likely to use an existing worker thread to run &lt;c3&gt;r&lt;/c3&gt;, or to place &lt;c4&gt;r&lt;/c4&gt; in a queue to wait for a worker thread to become available.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T031940Z" creationid="Admin" creationdate="20170630T031641Z">
        <seg>根据&lt;c1&gt;Executor&lt;/c1&gt; 的实现， &lt;c2&gt;execute&lt;/c2&gt; 可以完成同样的事，但更可能使用一个已存在的工作线程来执行&lt;c3&gt;r&lt;/c3&gt;，或者把 &lt;c4&gt;r&lt;/c4&gt; 放到队列中等待可用的工作线程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Documentation</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T075847Z" creationid="Admin" creationdate="20170630T075847Z">
        <seg>文档</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Don't allow subclasses to override methods.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170626T022329Z" creationid="Admin" creationdate="20170626T022329Z">
        <seg>不要允许子类重写方法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Don't assume that the interrupt was for the particular condition you were waiting for, or that the condition is still true.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T091510Z" creationid="Admin" creationdate="20170623T091510Z">
        <seg>不要假设中断是针对您正在等待的特定条件，或者假设该条件仍然为真。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Don't provide "setter" methods  methods that modify fields or objects referred to by fields.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170626T022245Z" creationid="Admin" creationdate="20170626T022245Z">
        <seg>不要提供"setter"方法——即修改字段引用的字段或对象的方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Don't provide methods that modify the mutable objects.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170626T022540Z" creationid="Admin" creationdate="20170626T022540Z">
        <seg>不提供修改可变对象的方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Don't share references to the mutable objects.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170626T022556Z" creationid="Admin" creationdate="20170626T022556Z">
        <seg>不共享可变对象的引用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each object represents the color as three integers that stand for primary color values and a string that gives the name of the color.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T100615Z" creationid="Admin" creationdate="20170623T100615Z">
        <seg>每一个对象代表一种颜色，使用三个整形数表示颜色的三基色，用一个字符串表示颜色名称。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each pixel is averaged with its surrounding pixels (the red, green, and blue components are averaged), and the result is placed in the destination array.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T070540Z" creationid="Admin" creationdate="20170630T070540Z">
        <seg>每个像素与其周围的像素（红色，绿色和蓝色分量被平均）进行平均，并将结果放在目标数组中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each thread is associated with an instance of the class &lt;a0&gt;&lt;c1&gt;Thread&lt;/c1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T042629Z" creationid="Admin" creationdate="20170622T042629Z">
        <seg>每个线程都与 &lt;a0&gt;&lt;c1&gt;Thread&lt;/c1&gt;&lt;/a0&gt;类的一个实例相关联。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Even a single application is often expected to do more than one thing at a time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T032436Z" creationid="Admin" creationdate="20170622T032436Z">
        <seg>即使是单一的应用程序通常也被期望同时做多件事情。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Even the word processor should always be ready to respond to keyboard and mouse events, no matter how busy it is reformatting text or updating the display.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T032532Z" creationid="Admin" creationdate="20170622T032532Z">
        <seg>即使文字处理器也应该随时准备好响应键盘和鼠标事件，无论重新格式化文本或更新显示器多么忙碌。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Even very simple expressions can define complex actions that can decompose into other actions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T072219Z" creationid="Admin" creationdate="20170623T072219Z">
        <seg>即使是非常简单的表达式也包含了复杂的动作，这些动作可以被解释成许多别的动作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Every application has at least one thread  or several, if you count "system" threads that do things like memory management and signal handling.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T042231Z" creationid="Admin" creationdate="20170622T042231Z">
        <seg>每个应用程序都至少有一个线程,或者几个,如果算上“系统”的线程（负责内存管理和信号处理）那就更多。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Every object has an intrinsic lock associated with it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T062404Z" creationid="Admin" creationdate="20170623T062404Z">
        <seg>每一个对象都有一个与之相关联动的内部锁。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Executor Interfaces</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T030328Z" creationid="Admin" creationdate="20170630T030328Z">
        <seg>执行器接口</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Executor implementations provided by &lt;c1&gt;java.util.concurrent&lt;/c1&gt; provide thread pool management suitable for large-scale applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T023429Z" creationid="Admin" creationdate="20170630T023429Z">
        <seg>Executor 的实现由 &lt;c1&gt;java.util.concurrent&lt;/c1&gt; 包提供，提供了适合大规模应用的线程池管理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Executors</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T025655Z" creationid="Admin" creationdate="20170630T025655Z">
        <seg>执行器（Executors）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Executors are discussed with other &lt;a1&gt;high-level concurrency objects&lt;/a1&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T062138Z" creationid="Admin" creationdate="20170622T062138Z">
        <seg>Executors在另外的 &lt;a1&gt;高级并发对象&lt;/a1&gt;中讨论</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Exercises</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T073928Z" creationid="Admin" creationdate="20170630T073928Z">
        <seg>练习</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, &lt;c2&gt;ExecutorService&lt;/c2&gt; provides a number of methods for managing the shutdown of the executor.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T062834Z" creationid="Admin" creationdate="20170630T062834Z">
        <seg>最后， &lt;c2&gt;ExecutorService&lt;/c2&gt; 还提供了一些关闭执行器的方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, here is the main thread, defined in &lt;a0&gt;&lt;c1&gt;&lt;c2&gt;ProducerConsumerExample&lt;/c2&gt;&lt;/c1&gt;&lt;/a0&gt;, that launches the producer and consumer threads.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T094709Z" creationid="Admin" creationdate="20170623T094709Z">
        <seg>最后&lt;a0&gt;&lt;c1&gt;&lt;c2&gt;ProducerConsumerExample&lt;/c2&gt;&lt;/c1&gt;&lt;/a0&gt;中定义主线程，它启动生产者和消费者线程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>First, it is not possible for two invocations of synchronized methods on the same object to interleave.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T101054Z" creationid="Admin" creationdate="20170622T101054Z">
        <seg>首先，不可能出现对同一对象的同步方法的两个调用的“交错”。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For Further Reading</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T073548Z" creationid="Admin" creationdate="20170630T073548Z">
        <seg>扩展阅读</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For a list of actions that create happens-before relationships, refer to the &lt;a0&gt;Summary page of the &lt;c1&gt;java.util.concurrent&lt;/c1&gt; package.&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T092924Z" creationid="Admin" creationdate="20170622T092924Z">
        <seg>关于哪些操作可以建立这种 happens-before，更多的信息请参阅&lt;a0&gt;&lt;c1&gt;java.util.concurrent&lt;/c1&gt; 包的概要说明&lt;/a0&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For concurrent access, using &lt;c0&gt;ThreadLocalRandom&lt;/c0&gt; instead of &lt;c1&gt;Math.random()&lt;/c1&gt; results in less contention and, ultimately, better performance.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T073416Z" creationid="Admin" creationdate="20170630T073416Z">
        <seg>对于并发访问，使用  &lt;c0&gt;ThreadLocalRandom&lt;/c0&gt; 代替 &lt;c1&gt;Math.random()&lt;/c1&gt; 可以减少竞争，从而获得更好的性能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, suppose an object provides a synchronized method that often takes a long time to return.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T080023Z" creationid="Admin" creationdate="20170623T080023Z">
        <seg>例如，假设一个对象提供一个同步的方法，往往需要很长时间返回。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, suppose the central message loop in the &lt;c2&gt;SleepMessages&lt;/c2&gt; example were in the &lt;c3&gt;run&lt;/c3&gt; method of a thread's &lt;c4&gt;Runnable&lt;/c4&gt; object.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T074610Z" creationid="Admin" creationdate="20170622T074610Z">
        <seg>例如，&lt;c2&gt;SleepMessages&lt;/c2&gt; 示例在线程的 &lt;c4&gt;Runnable&lt;/c4&gt; 对象中的 &lt;c3&gt;run&lt;/c3&gt;方法中支持消息循环。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, suppose you want to maintain a &lt;c1&gt;List&lt;/c1&gt; called &lt;c2&gt;instances&lt;/c2&gt; containing every instance of class.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T102435Z" creationid="Admin" creationdate="20170622T102435Z">
        <seg>例如，假定你想要维护一个保存所有类的实例的&lt;c1&gt;列表&lt;/c1&gt; ： &lt;c2&gt;instances&lt;/c2&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, that streaming audio application must simultaneously read the digital audio off the network, decompress it, manage playback, and update its display.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T032505Z" creationid="Admin" creationdate="20170622T032505Z">
        <seg>例如，流式音频应用程序必须同时从网络读取数字音频，解压缩，管理播放以及更新其显示。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T074905Z" creationid="Admin" creationdate="20170622T074905Z">
        <seg>例如：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information, refer to the &lt;a3&gt;Questions and Exercises&lt;/a3&gt; section.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T094922Z" creationid="Admin" creationdate="20170623T094922Z">
        <seg>更多信息，参见：&lt;a3&gt;Questions and Exercises&lt;/a3&gt; 部分。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information, see the &lt;a2&gt;Lambda Expressions&lt;/a2&gt; section.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T071853Z" creationid="Admin" creationdate="20170630T071853Z">
        <seg>想要了解更多信息，请参见 &lt;a2&gt;Lambda Expressions&lt;/a2&gt;一节。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For the full source code, including some extra code that creates the destination image file, see the &lt;a0&gt;&lt;c1&gt;&lt;c2&gt;ForkBlur&lt;/c2&gt;&lt;/c1&gt;&lt;/a0&gt; example.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T071328Z" creationid="Admin" creationdate="20170630T071328Z">
        <seg>想要浏览完成的源代码，请查看 &lt;a0&gt;&lt;c1&gt;&lt;c2&gt;ForkBlur&lt;/c2&gt;&lt;/c1&gt;&lt;/a0&gt; 示例，其中还包含一些创建 destination 图片文件的额外代码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For the interrupt mechanism to work correctly, the interrupted thread must support its own interruption.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T073935Z" creationid="Admin" creationdate="20170622T073935Z">
        <seg>为了中断机制能正常工作，被中断的线程必须支持自己的中断。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For this information, see the Java API documentation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T071744Z" creationid="Admin" creationdate="20170630T071744Z">
        <seg>想要了解更多的信息，请参见 Java API 文档。 </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For this simple class, synchronization is an acceptable solution.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T073016Z" creationid="Admin" creationdate="20170630T073016Z">
        <seg>对于这个简单的类，同步是一种可接受的解决方案。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Fortunately, the programmer does not need a detailed understanding of these causes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T091831Z" creationid="Admin" creationdate="20170622T091831Z">
        <seg>幸运的是，编程人员不需要详细了解这些原因。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Guarded Blocks</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T082650Z" creationid="Admin" creationdate="20170623T082650Z">
        <seg>保护块（Guarded Blocks）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here is one example:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T073457Z" creationid="Admin" creationdate="20170630T073457Z">
        <seg>下面是一个例子：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here is one possible implementation:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T070627Z" creationid="Admin" creationdate="20170630T070627Z">
        <seg>这是一个可能的实现：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here is the source code for the improved model, &lt;a4&gt;&lt;c5&gt;&lt;c6&gt;Safelock&lt;/c6&gt;&lt;/c5&gt;&lt;/a4&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T025022Z" creationid="Admin" creationdate="20170630T025022Z">
        <seg>下面是改善后模型的源代码  &lt;a4&gt;&lt;c5&gt;&lt;c6&gt;Safelock&lt;/c6&gt;&lt;/c5&gt;&lt;/a4&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here's an example.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T074447Z" creationid="Admin" creationdate="20170623T074447Z">
        <seg>下面是一个例子。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>High Level Concurrency Objects</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T022254Z" creationid="Admin" creationdate="20170630T022254Z">
        <seg>高级并发对象</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>How does a thread support its own interruption?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T074151Z" creationid="Admin" creationdate="20170622T074151Z">
        <seg>如何实现线程支持自己的中断？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>How would you guarantee that all changes to &lt;c1&gt;message&lt;/c1&gt; will be visible in the main thread?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T074143Z" creationid="Admin" creationdate="20170630T074143Z">
        <seg>您如何保证所有更改&lt;c1&gt;message&lt;/c1&gt;将在主线程中可见？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, as with &lt;c2&gt;sleep&lt;/c2&gt;, &lt;c3&gt;join&lt;/c3&gt; is dependent on the OS for timing, so you should not assume that &lt;c4&gt;join&lt;/c4&gt; will wait exactly as long as you specify.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T080105Z" creationid="Admin" creationdate="20170622T080105Z">
        <seg>然而，和&lt;c2&gt;sleep&lt;/c2&gt;一样，&lt;c3&gt;join&lt;/c3&gt; 依赖于操作系统的计时，所以你不能假定&lt;c4&gt;join&lt;/c4&gt; 等待的时间是精确的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, even simple statements can translate to multiple steps by the virtual machine.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T085013Z" creationid="Admin" creationdate="20170622T085013Z">
        <seg>然而，即使是一条语句也是会被虚拟机翻译成多个步骤的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, how exactly the fork/join framework is leveraged by these methods is outside the scope of the Java Tutorials.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T071734Z" creationid="Admin" creationdate="20170630T071734Z">
        <seg>这些方法究竟是如何运用 fork/join 框架并不在本教程的讨论范围内。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, if a &lt;c5&gt;Counter&lt;/c5&gt; object is referenced from multiple threads, interference between threads may prevent this from happening as expected.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T084629Z" creationid="Admin" creationdate="20170622T084629Z">
        <seg>然而，如果一个 &lt;c5&gt;Counter&lt;/c5&gt; 被多个线程引用，那么线程间的干扰就可能导致出现我们不想要的结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, it's always possible that interrupt status will immediately be set again, by another thread invoking &lt;c1&gt;interrupt&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T075408Z" creationid="Admin" creationdate="20170622T075408Z">
        <seg>当然，它可能因为另一个线程调用 &lt;c1&gt;interrupt&lt;/c1&gt;而让那个中断状态立即被重新设置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, processes are also important.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T034330Z" creationid="Admin" creationdate="20170622T034330Z">
        <seg>但是，进程也是重要的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, such strategies require sophisticated analysis and are not for beginners.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170626T022142Z" creationid="Admin" creationdate="20170626T022142Z">
        <seg>但这需要非常复杂细致的分析，并不适用于初学者。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, synchronization can introduce &lt;a0&gt;&lt;e1&gt;thread contention&lt;/e1&gt;&lt;/a0&gt;, which occurs when two or more threads try to access the same resource simultaneously &lt;e2&gt;and&lt;/e2&gt; cause the Java runtime to execute one or more threads more slowly, or even suspend their execution.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T083442Z" creationid="Admin" creationdate="20170622T083442Z">
        <seg>但是，同步可以引入&lt;a0&gt; &lt;e1&gt;线程争用（thread contention）&lt;/ e1&gt; &lt;/ a0&gt;，当两个或更多个线程尝试同时访问相同的资源时，会发生这种情况&lt;e2&gt;并&lt;/ e2&gt;导致Java运行时执行 一个或多个线程更慢，甚至暂停执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the definition of &lt;c0&gt;execute&lt;/c0&gt; is less specific.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T031329Z" creationid="Admin" creationdate="20170630T031329Z">
        <seg>然而， &lt;c0&gt;execute&lt;/c0&gt; 没有定义具体的实现方式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the threads are not blocked  they are simply too busy responding to each other to resume work.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T081857Z" creationid="Admin" creationdate="20170623T081857Z">
        <seg>然而，线程是不会阻塞的，他们只是会忙于应对彼此的恢复工作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, there are actions you can specify that are atomic:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T072302Z" creationid="Admin" creationdate="20170623T072302Z">
        <seg>但是，有一些动作可以指定是原子操作：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, these sleep times are not guaranteed to be precise, because they are limited by the facilities provided by the underlying OS.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T071308Z" creationid="Admin" creationdate="20170622T071308Z">
        <seg>然而，这些睡眠时间不能保证是准确的，因为它们受底层操作系统提供的设施的限制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, this does not eliminate all need to synchronize atomic actions, because memory consistency errors are still possible.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T073009Z" creationid="Admin" creationdate="20170623T073009Z">
        <seg>然而，这并不意味着可以移除对原子操作的同步，因为内存一致性错误还是有可能出现的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, what the user sees as a single application may in fact be a set of cooperating processes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T041642Z" creationid="Admin" creationdate="20170622T041642Z">
        <seg>然而,用户将看到一个单独的应用程序可能实际上是一组合作的进程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>IPC is used not just for communication between processes on the same system, but processes on different systems.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T041818Z" creationid="Admin" creationdate="20170622T041818Z">
        <seg>IPC 不仅用于同个系统的进程之间的通信，也可以用在不同系统的进程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If &lt;c0&gt;count&lt;/c0&gt; is an instance of &lt;c1&gt;SynchronizedCounter&lt;/c1&gt;, then making these methods synchronized has two effects:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T100613Z" creationid="Admin" creationdate="20170622T100613Z">
        <seg>如果&lt;c0&gt;count&lt;/c0&gt; 是&lt;c1&gt;SynchronizedCounter&lt;/c1&gt;的实例，设置其方法为同步方法将有两个效果：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If &lt;c1&gt;t&lt;/c1&gt; is a &lt;c2&gt;Thread&lt;/c2&gt; object whose thread is currently executing,</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T075652Z" creationid="Admin" creationdate="20170622T075652Z">
        <seg>如果 &lt;c1&gt;t&lt;/c1&gt; 是一个线程正在执行的 &lt;c2&gt;Thread&lt;/c2&gt; 对象，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If &lt;c3&gt;r&lt;/c3&gt; is a &lt;c4&gt;Runnable&lt;/c4&gt; object, and &lt;c5&gt;e&lt;/c5&gt; is an &lt;c6&gt;Executor&lt;/c6&gt; object you can replace</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T031232Z" creationid="Admin" creationdate="20170630T030854Z">
        <seg>如果&lt;c3&gt;r&lt;/c3&gt; 是一个 &lt;c4&gt;Runnable&lt;/c4&gt; 对象，&lt;c5&gt;e&lt;/c5&gt; 是一个 &lt;c6&gt;Executor&lt;/c6&gt; 对象，可以将</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If another thread invokes &lt;c0&gt;color.set&lt;/c0&gt; after Statement 1 but before Statement 2, the value of &lt;c1&gt;myColorInt&lt;/c1&gt; won't match the value of &lt;c2&gt;myColorName&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T101121Z" creationid="Admin" creationdate="20170623T101121Z">
        <seg>如果有另外一个线程在Statement 1之后、Statement 2之前调用了&lt;c0&gt;color.set&lt;/c0&gt;方法，那么&lt;c1&gt;myColorInt&lt;/c1&gt; 的值和 &lt;c2&gt;myColorName&lt;/c2&gt;的值就会不匹配。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If interrupted before it has printed all its messages, the &lt;c1&gt;MessageLoop&lt;/c1&gt; thread prints a message and exits.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T080623Z" creationid="Admin" creationdate="20170622T080623Z">
        <seg>在打印完所有消息之前中断，&lt;c1&gt; MessageLoop &lt;/c1&gt;线程将打印一条消息并退出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If none of the executors provided by the above factory methods meet your needs, constructing instances of &lt;a0&gt;&lt;c1&gt;java.util.concurrent.ThreadPoolExecutor&lt;/c1&gt;&lt;/a0&gt; or &lt;a2&gt;&lt;c3&gt;java.util.concurrent.ScheduledThreadPoolExecutor&lt;/c3&gt;&lt;/a2&gt; will give you additional options.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T065007Z" creationid="Admin" creationdate="20170630T065007Z">
        <seg>如果上述工厂方法提供的执行器不满足你的需要，创建一个 &lt;a0&gt;&lt;c1&gt;java.util.concurrent.ThreadPoolExecutor&lt;/c1&gt;&lt;/a0&gt; 或 &lt;a2&gt;&lt;c3&gt;java.util.concurrent.ScheduledThreadPoolExecutor&lt;/c3&gt;&lt;/a2&gt; 可以给你额外的选项。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If not, why not?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T074051Z" creationid="Admin" creationdate="20170630T074051Z">
        <seg>如果没有，为什么不呢？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If one thread invokes this method frequently, other threads that also need frequent synchronized access to the same object will often be blocked.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T080109Z" creationid="Admin" creationdate="20170623T080109Z">
        <seg>如果一个线程频繁调用该方法，其他线程若也需要频繁的同步访问同一个对象，通常就会被阻塞。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the &lt;c4&gt;MessageLoop&lt;/c4&gt; thread takes too long to finish, the main thread interrupts it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T080535Z" creationid="Admin" creationdate="20170622T080535Z">
        <seg>如果&lt;c4&gt;MessageLoop&lt;/c4&gt; 需要很长时间才能完成，主线程就中断它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the application simply creates a new thread for every new HTTP request, and the system receives more requests than it can handle immediately, the application will suddenly stop responding to &lt;i1&gt;all&lt;/i1&gt; requests when the overhead of all those threads exceed the capacity of the system.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T064301Z" creationid="Admin" creationdate="20170630T064301Z">
        <seg>如果应用程序只是为每个新的HTTP请求创建一个新的线程，系统收到的请求比它可以立即处理的更多时，所有这些线程的开销超过系统的容量，应用程序将突然停止响应&lt;i1&gt;所有&lt;/ i1&gt;请求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the initial value of &lt;c2&gt;c&lt;/c2&gt; is &lt;c3&gt;0&lt;/c3&gt;, their interleaved actions might follow this sequence:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T091017Z" creationid="Admin" creationdate="20170622T091017Z">
        <seg>如果 &lt;c2&gt;c&lt;/c2&gt; 的初始值是 &lt;c3&gt;0&lt;/c3&gt;，它们交错的操作顺序可能如下：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the instance fields include references to mutable objects, don't allow those objects to be changed:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170626T022524Z" creationid="Admin" creationdate="20170626T022524Z">
        <seg>如果实例字段包含对可变对象的引用，不要允许更改这些对象：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the other thread's action is also a response to the action of another thread, then &lt;i0&gt;livelock&lt;/i0&gt; may result.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T081644Z" creationid="Admin" creationdate="20170623T081617Z">
        <seg>如果该另一个线程的动作也是对另一个线程的动作的响应，则可能导致&lt;i0&gt; 活锁 &lt;/i0&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the previous methods are in a subclass of the &lt;c0&gt;RecursiveAction&lt;/c0&gt; class, then setting up the task to run in a &lt;c1&gt;ForkJoinPool&lt;/c1&gt; is straightforward, and involves the following steps:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T071040Z" creationid="Admin" creationdate="20170630T071040Z">
        <seg>如果前面这个方法是在一个  &lt;c0&gt;RecursiveAction&lt;/c0&gt; 子类中，那么设置任务在 &lt;c1&gt;ForkJoinPool&lt;/c1&gt; 是直观的。通常会包含以下一些步骤：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the thread is frequently invoking methods that throw &lt;c0&gt;InterruptedException&lt;/c0&gt;, it simply returns from the &lt;c1&gt;run&lt;/c1&gt; method after it catches that exception.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T074324Z" creationid="Admin" creationdate="20170622T074324Z">
        <seg>如果线程频繁调用抛出 &lt;c0&gt;InterruptedException&lt;/c0&gt;的方法，它只要在  &lt;c1&gt;run&lt;/c1&gt; 方法捕获了异常之后返回即可。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the two statements had been executed in the same thread, it would be safe to assume that the value printed out would be "1".</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T092248Z" creationid="Admin" creationdate="20170622T092248Z">
        <seg>如果以上两条语句是在同一个线程中执行的，那么输出的结果自然是1。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Immutable Objects</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T094959Z" creationid="Admin" creationdate="20170623T094959Z">
        <seg>不可变对象（Immutable Objects）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Immutable objects are particularly useful in concurrent applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T095841Z" creationid="Admin" creationdate="20170623T095841Z">
        <seg>不可变对象在并发应用程序中特别有用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In JDK 7, &lt;a0&gt;&lt;c1&gt;java.util.concurrent&lt;/c1&gt;&lt;/a0&gt; includes a convenience class, &lt;a2&gt;&lt;c3&gt;ThreadLocalRandom&lt;/c3&gt;&lt;/a2&gt;, for applications that expect to use random numbers from multiple threads or &lt;c4&gt;ForkJoinTask&lt;/c4&gt;s.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T073335Z" creationid="Admin" creationdate="20170630T073335Z">
        <seg>在 JDK7 中，&lt;a0&gt;&lt;c1&gt;java.util.concurrent&lt;/c1&gt;&lt;/a0&gt; 包含了一个相当便利的类 &lt;a2&gt;&lt;c3&gt;ThreadLocalRandom&lt;/c3&gt;&lt;/a2&gt;，可以在当应用程序期望在多个线程或  &lt;c4&gt;ForkJoinTask&lt;/c4&gt; 中使用随机数时使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, the interface defines &lt;c6&gt;scheduleAtFixedRate&lt;/c6&gt; and &lt;c7&gt;scheduleWithFixedDelay&lt;/c7&gt;, which executes specified tasks repeatedly, at defined intervals.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T063146Z" creationid="Admin" creationdate="20170630T063146Z">
        <seg>该接口还定义了 &lt;c6&gt;scheduleAtFixedRate&lt;/c6&gt; 以及 &lt;c7&gt;scheduleWithFixedDelay&lt;/c7&gt;，它们可以重复地、按指定间隔地执行指定的任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In all of the previous examples, there's a close connection between the task being done by a new thread, as defined by its &lt;c0&gt;Runnable&lt;/c0&gt; object, and the thread itself, as defined by a &lt;c1&gt;Thread&lt;/c1&gt; object.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T025711Z" creationid="Admin" creationdate="20170630T025711Z">
        <seg>在之前所有的例子中， &lt;c1&gt;Thread&lt;/c1&gt;  对象表示的线程和 &lt;c0&gt;Runnable&lt;/c0&gt; 对象表示的线程所执行的任务之间是紧耦合的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In any case, you cannot assume that invoking &lt;c1&gt;sleep&lt;/c1&gt; will suspend the thread for precisely the time period specified.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T071619Z" creationid="Admin" creationdate="20170622T071619Z">
        <seg>在任何情况下，你不能假设调用&lt;c1&gt;sleep&lt;/c1&gt;  会挂起线程用于指定精确的时间段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In concurrent programming, there are two basic units of execution: &lt;i0&gt;processes&lt;/i0&gt; and &lt;i1&gt;threads&lt;/i1&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T034256Z" creationid="Admin" creationdate="20170622T034256Z">
        <seg>并发编程的两个基本的执行单元是 &lt;i0&gt;进程&lt;/i0&gt; 和 &lt;i1&gt;线程&lt;/i1&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In more complex applications, it might make more sense to throw an &lt;c0&gt;InterruptedException&lt;/c0&gt;:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T075006Z" creationid="Admin" creationdate="20170622T075006Z">
        <seg>在更复杂的应用程序，它可能会更有意义抛出一个&lt;c0&gt;InterruptedException&lt;/c0&gt;：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In programming, an &lt;i0&gt;atomic&lt;/i0&gt; action is one that effectively happens all at once.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T072015Z" creationid="Admin" creationdate="20170623T072015Z">
        <seg>在编程中，&lt;i0&gt;原子性（atomic）&lt;/i0&gt;动作就是指一次性有效完成的动作。 </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In so doing, they give general rules for this kind of conversion and demonstrate some of the advantages of immutable objects.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T100308Z" creationid="Admin" creationdate="20170623T100308Z">
        <seg>通过这个例子说明转化的原则以及使用不可变对象的好处。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In such an application, you don't care which thread gets woken up.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T092747Z" creationid="Admin" creationdate="20170623T092747Z">
        <seg>在这样的应用程序中，你不用在乎哪个线程被唤醒。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the Java programming language, concurrent programming is mostly concerned with threads.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T034313Z" creationid="Admin" creationdate="20170622T034313Z">
        <seg>在 Java 中，并发编程主要涉及线程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case, the thread acquires the intrinsic lock for the &lt;c0&gt;Class&lt;/c0&gt; object associated with the class.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T063914Z" creationid="Admin" creationdate="20170623T063914Z">
        <seg>在这种情况下，线程获取的是与该类相关的&lt;c0&gt;Class&lt;/c0&gt; 对象的内部锁。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this example, the &lt;c0&gt;addName&lt;/c0&gt; method needs to synchronize changes to &lt;c1&gt;lastName&lt;/c1&gt; and &lt;c2&gt;nameCount&lt;/c2&gt;, but also needs to avoid synchronizing invocations of other objects' methods.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T064910Z" creationid="Admin" creationdate="20170623T064825Z">
        <seg>在上面的标例中 &lt;c0&gt;addName&lt;/c0&gt; 方法需要对&lt;c1&gt;lastName&lt;/c1&gt; 和 &lt;c2&gt;nameCount&lt;/c2&gt;的修改进行同步，但是也需要避免同步调用其他对象的方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this example, the data is a series of text messages, which are shared through an object of type &lt;a0&gt;&lt;c1&gt;&lt;c2&gt;Drop&lt;/c2&gt;&lt;/c1&gt;&lt;/a0&gt;:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T093658Z" creationid="Admin" creationdate="20170623T093658Z">
        <seg>在该例子中，数据是一系列文本消息，通过一个&lt;a0&gt;&lt;c1&gt;&lt;c2&gt;Drop&lt;/c2&gt;&lt;/c1&gt;&lt;/a0&gt;类的对象共享：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this example, we can just ignore that exception  we only care about the value of &lt;c2&gt;joy&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T091700Z" creationid="Admin" creationdate="20170623T091700Z">
        <seg>在上面的例子中，我们只关心 &lt;c2&gt;joy&lt;/c2&gt;的值，所以忽略了异常。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this section we'll look at some of the high-level concurrency features introduced with version 5.0 of the Java platform.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T022841Z" creationid="Admin" creationdate="20170630T022841Z">
        <seg>在本节中，我们将介绍Java平台版本5.0引入的一些高级并发功能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this simple example, the code simply tests for the interrupt and exits the thread if one has been received.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T074949Z" creationid="Admin" creationdate="20170622T074949Z">
        <seg>在这个简单的例子中，代码简单地测试该中断，如果已接收到中断线程就退出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Increment the retrieved value by 1.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T085209Z" creationid="Admin" creationdate="20170622T085209Z">
        <seg>对其当前值加 1。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead of using synchronized methods or otherwise using the lock associated with &lt;c3&gt;this&lt;/c3&gt;, we create two objects solely to provide locks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T065848Z" creationid="Admin" creationdate="20170623T065848Z">
        <seg>我们创建2个对象各自提供锁，而不是使用同步方法或者使用与&lt;c3&gt;this&lt;/c3&gt;相关的锁。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Interference happens when two operations, running in different threads, but acting on the same data, &lt;i0&gt;interleave&lt;/i0&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T084715Z" creationid="Admin" creationdate="20170622T084715Z">
        <seg>线程间的干扰出现在多个线程对同一个数据进行多个操作的时候，也就是出现了&lt;i0&gt;交错（interleave）&lt;/i0&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Interrupts</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T072627Z" creationid="Admin" creationdate="20170622T072605Z">
        <seg>中断（interrupt）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Intrinsic Locks and Synchronization</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T103601Z" creationid="Admin" creationdate="20170622T103601Z">
        <seg>内部锁和同步</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Invoking &lt;c1&gt;Thread.interrupt&lt;/c1&gt; sets this flag.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T075142Z" creationid="Admin" creationdate="20170622T075142Z">
        <seg>调用&lt;c1&gt; Thread.interrupt &lt;/c1&gt;设置此标志。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Invoking &lt;c5&gt;wait&lt;/c5&gt; inside a synchronized method is a simple way to acquire the intrinsic lock.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T092006Z" creationid="Admin" creationdate="20170623T092006Z">
        <seg>在一个同步方法内调用&lt;c5&gt;wait&lt;/c5&gt; 是获取内部锁的简单方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is designed for work that can be broken into smaller pieces recursively.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T065159Z" creationid="Admin" creationdate="20170630T065159Z">
        <seg>它被设计用于可以递归地分解成更小的部分的工作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It might not seem possible for operations on instances of &lt;c0&gt;Counter&lt;/c0&gt; to interleave, since both operations on &lt;c1&gt;c&lt;/c1&gt; are single, simple statements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T084943Z" creationid="Admin" creationdate="20170622T084857Z">
        <seg>&lt;c0&gt;Counter&lt;/c0&gt; 类对象的操作貌似不可能出现这种交错（interleave），因为其中的两个关于 &lt;c1&gt;c&lt;/c1&gt; 的操作都很简单，只有一条语句。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's becoming more and more common for computer systems to have multiple processors or processors with multiple execution cores.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T034657Z" creationid="Admin" creationdate="20170622T034657Z">
        <seg>现在多核处理器或多进程的电脑系统越来越流行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's up to the programmer to decide exactly how a thread responds to an interrupt, but it is very common for the thread to terminate.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T072819Z" creationid="Admin" creationdate="20170622T072819Z">
        <seg>由程序员决定线程如何响应一个中断，但线程终止是非常常见的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Lesson: Concurrency</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T080248Z" creationid="Admin" creationdate="20170630T080248Z">
        <seg>课程：并发</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Let's use &lt;c0&gt;Lock&lt;/c0&gt; objects to solve the deadlock problem we saw in &lt;a1&gt;Liveness&lt;/a1&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T024714Z" creationid="Admin" creationdate="20170630T024714Z">
        <seg>让我们使用&lt;c0&gt;Lock&lt;/c0&gt;  对象来解决我们在&lt;a1&gt;Liveness&lt;/a1&gt;见到的死锁问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Let's use guarded blocks to create a &lt;i0&gt;Producer-Consumer&lt;/i0&gt; application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T092822Z" creationid="Admin" creationdate="20170623T092822Z">
        <seg>让我们用保护块来创建一个&lt;i0&gt;Producer-Consumer&lt;/i0&gt; 应用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Like &lt;c0&gt;sleep&lt;/c0&gt;, &lt;c1&gt;join&lt;/c1&gt; responds to an interrupt by exiting with an &lt;c2&gt;InterruptedException&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T080225Z" creationid="Admin" creationdate="20170622T080225Z">
        <seg>和&lt;c0&gt;sleep&lt;/c0&gt;一样， &lt;c1&gt;join&lt;/c1&gt; 通过退出并带着一个 &lt;c2&gt;InterruptedException&lt;/c2&gt;来响应中断。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Like &lt;c4&gt;execute&lt;/c4&gt;, &lt;c5&gt;submit&lt;/c5&gt; accepts &lt;c6&gt;Runnable&lt;/c6&gt; objects, but also accepts &lt;a7&gt;&lt;c8&gt;Callable&lt;/c8&gt;&lt;/a7&gt; objects, which allow the task to return a value.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T062400Z" creationid="Admin" creationdate="20170630T062400Z">
        <seg>和 &lt;c4&gt;execute&lt;/c4&gt;一样， &lt;c5&gt;submit&lt;/c5&gt; 接受 &lt;c6&gt;Runnable&lt;/c6&gt; 对象的参数，同时也接受 &lt;a7&gt;&lt;c8&gt;Callable&lt;/c8&gt;&lt;/a7&gt; 对象的参数，Callable对象允许任务返回结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Like many methods that suspend execution, &lt;c0&gt;wait&lt;/c0&gt; can throw &lt;c1&gt;InterruptedException&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T091605Z" creationid="Admin" creationdate="20170623T091605Z">
        <seg>和其他可以暂停线程执行的方法一样&lt;c0&gt;wait&lt;/c0&gt; 会抛出 &lt;c1&gt;InterruptedException&lt;/c1&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Livelock</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T081446Z" creationid="Admin" creationdate="20170623T081446Z">
        <seg>活锁（Livelock）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Liveness</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T073908Z" creationid="Admin" creationdate="20170623T073908Z">
        <seg>活跃度（Liveness）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Lock Objects</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T023916Z" creationid="Admin" creationdate="20170630T023916Z">
        <seg>锁对象</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Locks In Synchronized Methods</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T063556Z" creationid="Admin" creationdate="20170623T063556Z">
        <seg>同步方法中的锁</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Make all fields &lt;c0&gt;final&lt;/c0&gt; and &lt;c1&gt;private&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170626T022317Z" creationid="Admin" creationdate="20170626T022317Z">
        <seg>将所有字段定义为&lt;c0&gt;final&lt;/c0&gt; 和 &lt;c1&gt;private&lt;/c1&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Making these operations atomic helps avoid synchronization.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T072207Z" creationid="Admin" creationdate="20170630T072207Z">
        <seg>使这些操作原子化，可以避免同步。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Many methods that throw &lt;c0&gt;InterruptedException&lt;/c0&gt;, such as &lt;c1&gt;sleep&lt;/c1&gt;, are designed to cancel their current operation and return immediately when an interrupt is received.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T074720Z" creationid="Admin" creationdate="20170622T074720Z">
        <seg>很多方法会抛出 &lt;c0&gt;InterruptedException&lt;/c0&gt;，如 &lt;c1&gt;sleep&lt;/c1&gt;，被设计成在收到中断时立即取消他们当前的操作并返回。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Maximum reliance on immutable objects is widely accepted as a sound strategy for creating simple, reliable code.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T095723Z" creationid="Admin" creationdate="20170623T095723Z">
        <seg>对不可变对象的最大依赖，普遍认为是创建简单可靠代码的良好策略。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Memory Consistency Errors</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T091421Z" creationid="Admin" creationdate="20170622T091421Z">
        <seg>内存一致性错误</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Modify the producer-consumer example in &lt;a0&gt;Guarded Blocks&lt;/a0&gt; to use a standard library class instead of the &lt;c1&gt;Drop&lt;/c1&gt; class.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T074213Z" creationid="Admin" creationdate="20170630T074213Z">
        <seg>修改&lt;a0&gt; Guarded Blocks &lt;/a0&gt;中的生产者消费者示例，使用标准库类而不是&lt;c1&gt; Drop &lt;/c1&gt;类。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>More sophisticated locking idioms are supported by the &lt;a0&gt;&lt;c1&gt;java.util.concurrent.locks&lt;/c1&gt;&lt;/a0&gt; package.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T024058Z" creationid="Admin" creationdate="20170630T024058Z">
        <seg>&lt;a0&gt;&lt;c1&gt;java.util.concurrent.locks&lt;/c1&gt;&lt;/a0&gt; 包提供了更复杂的锁。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most implementations of the Java virtual machine run as a single process.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T041828Z" creationid="Admin" creationdate="20170622T041828Z">
        <seg>大多数 Java 虚拟机的实现作为一个进程运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most of the executor implementations in &lt;c0&gt;java.util.concurrent&lt;/c0&gt; use &lt;i1&gt;thread pools&lt;/i1&gt;, which consist of &lt;i2&gt;worker threads&lt;/i2&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T063419Z" creationid="Admin" creationdate="20170630T063419Z">
        <seg>在&lt;c0&gt;java.util.concurrent&lt;/c0&gt; 包中多数的执行器实现都使用了由 &lt;i2&gt;worker threads&lt;/i2&gt;组成的 &lt;i1&gt;thread pools&lt;/i1&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most of these features are implemented in the new &lt;c0&gt;java.util.concurrent&lt;/c0&gt; packages.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T022924Z" creationid="Admin" creationdate="20170630T022924Z">
        <seg>大多数功能已经在新的 &lt;c0&gt;java.util.concurrent&lt;/c0&gt; 包中实现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Multiprocess applications are beyond the scope of this lesson.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T041915Z" creationid="Admin" creationdate="20170622T041915Z">
        <seg>多进程应用程序超出了本课的讲解范围。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Multithreaded execution is an essential feature of the Java platform.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T042211Z" creationid="Admin" creationdate="20170622T042211Z">
        <seg>多线程执行是 Java 平台的一个重要特点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Neither block will ever end, because each thread is waiting for the other to exit &lt;c2&gt;bow&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T075355Z" creationid="Admin" creationdate="20170623T075355Z">
        <seg>无论是哪个线程永远不会结束，因为每个线程都在等待对方退出&lt;c2&gt;bow&lt;/c2&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Never store references to external, mutable objects passed to the constructor; if necessary, create copies, and store references to the copies.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170626T022737Z" creationid="Admin" creationdate="20170626T022737Z">
        <seg>不要存储对传递给构造函数的外部可变对象的引用; 如有必要，请创建副本，并存储对副本的引用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>No side effects of an atomic action are visible until the action is complete.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T072130Z" creationid="Admin" creationdate="20170623T072130Z">
        <seg>在动作没有执行完毕之前，是不会产生可见结果的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Not all classes documented as "immutable" follow these rules.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170626T022036Z" creationid="Admin" creationdate="20170626T022036Z">
        <seg>不是所有被记录为“不可变”的类都遵循这些规则。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Not only is this approach more flexible, but it is applicable to the high-level thread management APIs covered later.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T065500Z" creationid="Admin" creationdate="20170622T065500Z">
        <seg>这不仅更灵活,而且它适用于高级线程管理 API。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that constructors cannot be synchronized  using the &lt;c0&gt;synchronized&lt;/c0&gt; keyword with a constructor is a syntax error.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T101815Z" creationid="Admin" creationdate="20170622T101815Z">
        <seg>注意：构造函数不能是 synchronized ——在构造函数前使用&lt;c0&gt;synchronized&lt;/c0&gt; 关键字将导致语义错误。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Notice that &lt;c0&gt;main&lt;/c0&gt; declares that it &lt;c1&gt;throws InterruptedException&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T072250Z" creationid="Admin" creationdate="20170622T072250Z">
        <seg>请注意 &lt;c0&gt;main&lt;/c0&gt; 申明了&lt;c1&gt;throws InterruptedException&lt;/c1&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Notice that both examples invoke &lt;c0&gt;Thread.start&lt;/c0&gt; in order to start the new thread.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T063622Z" creationid="Admin" creationdate="20170622T063622Z">
        <seg>请注意，这两个例子都执行 &lt;c0&gt;Thread.start&lt;/c0&gt; 以启动新的线程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now you implement the abstract &lt;c0&gt;compute()&lt;/c0&gt; method, which either performs the blur directly or splits it into two smaller tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T070833Z" creationid="Admin" creationdate="20170630T070833Z">
        <seg>接下来你需要实现抽象的&lt;c0&gt;compute()&lt;/c0&gt;  方法，它会直接执行模糊处理，或者将当前的工作拆分成两个更小的任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Objects that encapsulate these functions are known as &lt;i2&gt;executors&lt;/i2&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T025905Z" creationid="Admin" creationdate="20170630T025905Z">
        <seg>封装这些功能的对象就是 &lt;i2&gt;执行器（executors）&lt;/i2&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One common type of thread pool is the &lt;i0&gt;fixed thread pool&lt;/i0&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T063822Z" creationid="Admin" creationdate="20170630T063822Z">
        <seg>一种最常见的线程池是&lt;i0&gt;固定大小的线程池&lt;/i0&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One of them is synchronization, as we will see in the following sections.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T092500Z" creationid="Admin" creationdate="20170622T092500Z">
        <seg>使用同步（synchronization）就是其中之一，这点我们将会在下面的小节中看到。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One such implementation, introduced in Java SE 8, is used by the &lt;a1&gt;&lt;c2&gt;java.util.Arrays&lt;/c2&gt;&lt;/a1&gt; class for its &lt;c3&gt;parallelSort()&lt;/c3&gt; methods.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T071542Z" creationid="Admin" creationdate="20170630T071542Z">
        <seg>&lt;a1&gt;&lt;c2&gt;java.util.Arrays&lt;/c2&gt;&lt;/a1&gt; 类的&lt;c3&gt;parallelSort()&lt;/c3&gt; 方法就使用了 fork/join 来实现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One way to make &lt;c0&gt;Counter&lt;/c0&gt; safe from thread interference is to make its methods synchronized, as in &lt;a1&gt;&lt;c2&gt;&lt;c3&gt;SynchronizedCounter&lt;/c3&gt;&lt;/c2&gt;&lt;/a1&gt;:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T072959Z" creationid="Admin" creationdate="20170630T072959Z">
        <seg>使用同步是一种使 &lt;c0&gt;Counter&lt;/c0&gt; 类变得线程安全的方法，如&lt;a1&gt;&lt;c2&gt;&lt;c3&gt;SynchronizedCounter&lt;/c3&gt;&lt;/c2&gt;&lt;/a1&gt;：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Only one field refers to an object, and that object is itself immutable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170626T025929Z" creationid="Admin" creationdate="20170626T025929Z">
        <seg>只有一个字段是指一个对象，该对象本身是不可变的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Overloads of &lt;c1&gt;join&lt;/c1&gt; allow the programmer to specify a waiting period.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T075815Z" creationid="Admin" creationdate="20170622T075815Z">
        <seg>重载&lt;c1&gt; join &lt;/c1&gt;方法允许程序员指定等待期。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Parallel sorting of large arrays is faster than sequential sorting when run on multiprocessor systems.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T071703Z" creationid="Admin" creationdate="20170630T071703Z">
        <seg>在多处理器系统中，对大数组的并排序会比顺序排序更快。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Pausing Execution with Sleep</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T070638Z" creationid="Admin" creationdate="20170622T070638Z">
        <seg>用Sleep来暂停执行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Performing the blur is accomplished by working through the source array one pixel at a time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T070505Z" creationid="Admin" creationdate="20170630T070505Z">
        <seg>对图片的模糊操作是通过对 source 数组中的每一个像素点进行处理完成的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Processes</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T041408Z" creationid="Admin" creationdate="20170622T041408Z">
        <seg>进程</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Processes and Threads</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T033307Z" creationid="Admin" creationdate="20170622T033307Z">
        <seg>进程和线程</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Processes are often seen as synonymous with programs or applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T041627Z" creationid="Admin" creationdate="20170622T041627Z">
        <seg>进程往往被视为等同于程序或应用程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Processing time for a single core is shared among processes and threads through an OS feature called time slicing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T034634Z" creationid="Admin" creationdate="20170622T034634Z">
        <seg>对于单核处理器来说，处理时间是通过时间切片来在进程和线程之间进行共享的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Programmers are often reluctant to employ immutable objects, because they worry about the cost of creating a new object as opposed to updating an object in place.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T100056Z" creationid="Admin" creationdate="20170623T100056Z">
        <seg>序员往往不愿使用不可变对象，因为他们担心创建一个新的对象要比更新对象的成本要高。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Questions</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T073849Z" creationid="Admin" creationdate="20170630T073849Z">
        <seg>问题</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Questions and Exercises</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T080138Z" creationid="Admin" creationdate="20170630T080138Z">
        <seg>问题和练习</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Questions and Exercises: Concurrency</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T073844Z" creationid="Admin" creationdate="20170630T073844Z">
        <seg>问题和练习：并发</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Reads and writes are atomic for &lt;i0&gt;all&lt;/i0&gt; variables declared &lt;c1&gt;volatile&lt;/c1&gt; (&lt;i2&gt;including&lt;/i2&gt; &lt;c3&gt;long&lt;/c3&gt; and &lt;c4&gt;double&lt;/c4&gt; variables).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T072559Z" creationid="Admin" creationdate="20170623T072559Z">
        <seg>对 &lt;i0&gt;所有&lt;/i0&gt; 申明为 &lt;c1&gt;volatile&lt;/c1&gt; 的变量的读写是原子的（&lt;i2&gt;包括&lt;/i2&gt; &lt;c3&gt;long&lt;/c3&gt; 和 &lt;c4&gt;double&lt;/c4&gt; 类型）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Reads and writes are atomic for reference variables and for most primitive variables (all types except &lt;c0&gt;long&lt;/c0&gt; and &lt;c1&gt;double&lt;/c1&gt;).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T072440Z" creationid="Admin" creationdate="20170623T072440Z">
        <seg>对几乎所有的基本数据类型变量（除了 &lt;c0&gt;long&lt;/c0&gt; 和 &lt;c1&gt;double&lt;/c1&gt;）的读写以及引用变量的读写都是原子的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Recall that a thread cannot acquire a lock owned by another thread.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T070312Z" creationid="Admin" creationdate="20170623T070312Z">
        <seg>回忆前面提到的：线程不能获取已经被别的线程获取的锁。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Reentrant Synchronization</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T070133Z" creationid="Admin" creationdate="20170623T070133Z">
        <seg>重入同步（Reentrant Synchronization）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Replacing the &lt;c0&gt;int&lt;/c0&gt; field with an &lt;c1&gt;AtomicInteger&lt;/c1&gt; allows us to prevent thread interference without resorting to synchronization, as in &lt;a2&gt;&lt;c3&gt;&lt;c4&gt;AtomicCounter&lt;/c4&gt;&lt;/c3&gt;&lt;/a2&gt;:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T073138Z" creationid="Admin" creationdate="20170630T073138Z">
        <seg>将 &lt;c0&gt;int&lt;/c0&gt; 替换为  &lt;c1&gt;AtomicInteger&lt;/c1&gt;  允许我们在不进行同步的情况下阻止线程干扰，如 &lt;a2&gt;&lt;c3&gt;&lt;c4&gt;AtomicCounter&lt;/c4&gt;&lt;/c3&gt;&lt;/a2&gt;：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Retrieve the current value of &lt;c0&gt;c&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T085159Z" creationid="Admin" creationdate="20170622T085159Z">
        <seg>获取 &lt;c0&gt;c&lt;/c0&gt;的当前值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Run the task.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T071315Z" creationid="Admin" creationdate="20170630T071315Z">
        <seg>执行任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Second, when a synchronized method exits, it automatically establishes a happens-before relationship with &lt;i0&gt;any subsequent invocation&lt;/i0&gt; of a synchronized method for the same object.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T101722Z" creationid="Admin" creationdate="20170622T101722Z">
        <seg>其次，当一个同步方法退出时，会自动与该对象的同步方法的&lt;i0&gt;任何后续调用&lt;/i0&gt; 建立 happens-before 关系。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See the section &lt;a4&gt;Liveness&lt;/a4&gt; for more information.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T083553Z" creationid="Admin" creationdate="20170622T083553Z">
        <seg>更多信息参见&lt;a4&gt;Liveness&lt;/a4&gt; ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Seeing that they are still blocking each other, Alphone moves to his right, while Gaston moves to his left.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T082215Z" creationid="Admin" creationdate="20170623T082215Z">
        <seg>看到他们仍然相互阻挠，Alphone向右移动，而Gaston向左移动。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Several factory methods are &lt;c0&gt;ScheduledExecutorService&lt;/c0&gt; versions of the above executors.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T064840Z" creationid="Admin" creationdate="20170630T064840Z">
        <seg>上述执行器的几个工厂方法&lt;c0&gt;ScheduledExecutorService&lt;/c0&gt; 版本的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, create copies of your internal mutable objects when necessary to avoid returning the originals in your methods.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170626T022818Z" creationid="Admin" creationdate="20170626T022818Z">
        <seg>同样如果需要返回内部的可变对象时，不要返回可变对象本身，而是返回其拷贝。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since an image is a large array, this process can take a long time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T070553Z" creationid="Admin" creationdate="20170630T070553Z">
        <seg>因为一张图片会由一个很大的数组来表示，这个流程会花费一段较长的时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since they cannot change state, they cannot be corrupted by thread interference or observed in an inconsistent state.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T100013Z" creationid="Admin" creationdate="20170623T100013Z">
        <seg>因为他们不能改变状态，它们不能被线程干扰所中断或者被其他线程观察到内部不一致的状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since this application has not defined another thread to cause the interrupt, it doesn't bother to catch &lt;c4&gt;InterruptedException&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T072404Z" creationid="Admin" creationdate="20170622T072404Z">
        <seg>由于该应用程序还没有定义的另一个线程来引起的中断，所以考虑捕捉 &lt;c4&gt;InterruptedException&lt;/c4&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since version 5.0, the Java platform has also included high-level concurrency APIs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T033038Z" creationid="Admin" creationdate="20170622T033038Z">
        <seg>自5.0版本以来，Java平台还包括高级并发API。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So far, this lesson has focused on the low-level APIs that have been part of the Java platform from the very beginning.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T022900Z" creationid="Admin" creationdate="20170630T022558Z">
        <seg>目前为止，之前的教程都是重点讲述了一开始就作为 Java 平台一部分的低级别 API。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Software that can do such things is known as &lt;i0&gt;concurrent&lt;/i0&gt; software.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T032616Z" creationid="Admin" creationdate="20170622T032616Z">
        <seg>可以执行此类操作的软件称为 &lt;i0&gt;并发&lt;/i0&gt; 软件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some time after the second thread has released the lock, the first thread reacquires the lock and resumes by returning from the invocation of &lt;c0&gt;wait&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T092345Z" creationid="Admin" creationdate="20170623T092345Z">
        <seg>在第二个线程释放锁一段时间后，第一个线程重新获取该锁，并通过从调用&lt;c0&gt; wait &lt;/c0&gt;的返回来恢复。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Standard Implementations</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T071344Z" creationid="Admin" creationdate="20170630T071344Z">
        <seg>标准实现</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Starvation</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T075742Z" creationid="Admin" creationdate="20170623T075742Z">
        <seg>饥饿（Starvation）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Starvation and Livelock</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T075538Z" creationid="Admin" creationdate="20170623T075538Z">
        <seg>饥饿和活锁（Starvation and Livelock）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Starvation and livelock are much less common a problem than deadlock, but are still problems that every designer of concurrent software is likely to encounter.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T075733Z" creationid="Admin" creationdate="20170623T075733Z">
        <seg>饥饿和活锁虽比死锁问题稍微不常见点，但这些是在并发软件中每一个设计者仍然可能会遇到的问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Store the incremented value back in &lt;c0&gt;c&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T085220Z" creationid="Admin" creationdate="20170622T085220Z">
        <seg>将增加后的值存储到  &lt;c0&gt;c&lt;/c0&gt;中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Such a block begins by polling a condition that must be true before the block can proceed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T085509Z" creationid="Admin" creationdate="20170623T085509Z">
        <seg>这样的块在运行前通过轮询检查一个条件，直到为真时才开始。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Such a method could, in theory, simply loop until the condition is satisfied, but that loop is wasteful, since it executes continuously while waiting.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T090523Z" creationid="Admin" creationdate="20170623T090523Z">
        <seg>这种方法在理论上可以简单地循环，直到条件满足为止，但是循环是浪费的，因为它在等待时持续执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Supporting Interruption</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T073942Z" creationid="Admin" creationdate="20170622T073942Z">
        <seg>支持中断</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Suppose &lt;c1&gt;d&lt;/c1&gt; is the object we're using to invoke &lt;c2&gt;wait&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T091824Z" creationid="Admin" creationdate="20170623T091755Z">
        <seg>假设 &lt;c1&gt;d&lt;/c1&gt; 是用来调用 &lt;c2&gt;wait&lt;/c2&gt;的对象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Suppose Thread A invokes &lt;c0&gt;increment&lt;/c0&gt; at about the same time Thread B invokes &lt;c1&gt;decrement&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T090915Z" creationid="Admin" creationdate="20170622T090915Z">
        <seg>假定线程 A 中调用 &lt;c0&gt;increment&lt;/c0&gt;方法，同时线程 B 中调用 &lt;c1&gt;decrement&lt;/c1&gt;方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Suppose a simple &lt;c1&gt;int&lt;/c1&gt; field is defined and initialized:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T092017Z" creationid="Admin" creationdate="20170622T092017Z">
        <seg>假定定义了一个简单的 &lt;c1&gt;int&lt;/c1&gt;  类型的字段并对其进行了初始化：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Suppose that you want to blur an image.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T070326Z" creationid="Admin" creationdate="20170630T070326Z">
        <seg>假设你想要模糊一张图片。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Suppose, for example &lt;c0&gt;guardedJoy&lt;/c0&gt; is a method that must not proceed until a shared variable &lt;c1&gt;joy&lt;/c1&gt; has been set by another thread.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T090352Z" creationid="Admin" creationdate="20170623T090352Z">
        <seg>比如，假设&lt;c0&gt;guardedJoy&lt;/c0&gt; 方法必须等待另外的线程给共享变量 &lt;c1&gt;joy&lt;/c1&gt; 设置值才能继续执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Suppose, for example, a thread executes the following code:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T100933Z" creationid="Admin" creationdate="20170623T100933Z">
        <seg>比如，假设一个线程执行了以下代码：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Suppose, for example, class &lt;c0&gt;MsLunch&lt;/c0&gt; has two instance fields, &lt;c1&gt;c1&lt;/c1&gt; and &lt;c2&gt;c2&lt;/c2&gt;, that are never used together.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T065515Z" creationid="Admin" creationdate="20170623T065515Z">
        <seg>例如，假如类&lt;c0&gt;MsLunch&lt;/c0&gt; 有两个实例字段， &lt;c1&gt;c1&lt;/c1&gt; 和 &lt;c2&gt;c2&lt;/c2&gt;，这两个变量绝不会一起使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Synchronization</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T082852Z" creationid="Admin" creationdate="20170622T082852Z">
        <seg>同步（Synchronization）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Synchronization is built around an internal entity known as the &lt;i0&gt;intrinsic lock&lt;/i0&gt; or &lt;i1&gt;monitor lock&lt;/i1&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T103914Z" creationid="Admin" creationdate="20170622T103914Z">
        <seg>同步是构建在被称为&lt;i0&gt;内部锁（intrinsic lock）&lt;/i0&gt; 或 &lt;i1&gt;监视锁（monitor lock）&lt;/i1&gt;的内部实体上的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Synchronized Methods</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T094510Z" creationid="Admin" creationdate="20170622T094510Z">
        <seg>同步方法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Synchronized Statements</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T064350Z" creationid="Admin" creationdate="20170623T064350Z">
        <seg>同步语名块</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Synchronized code relies on a simple kind of reentrant lock.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T024027Z" creationid="Admin" creationdate="20170630T024027Z">
        <seg>同步代码依赖于一种简单的可重入锁。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Synchronized methods enable a simple strategy for preventing thread interference and memory consistency errors: if an object is visible to more than one thread, all reads or writes to that object's variables are done through &lt;c0&gt;synchronized&lt;/c0&gt; methods.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T102826Z" creationid="Admin" creationdate="20170622T102826Z">
        <seg>同步方法是一种简单的可以避免线程相互干扰和内存一致性错误的策略：如果一个对象对多个线程都是可见的，那么所有对该对象的变量的读写都应该是通过 &lt;c0&gt;同步&lt;/c0&gt; 方法完成的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Synchronized statements are also useful for improving concurrency with fine-grained synchronization.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T065421Z" creationid="Admin" creationdate="20170623T065421Z">
        <seg>同步语句块对于通过细粒度（fine-grained）的同步来提高并发性也是有用的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Synchronizing constructors doesn't make sense, because only the thread that creates an object should have access to it while it is being constructed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T102217Z" creationid="Admin" creationdate="20170622T102217Z">
        <seg>同步构造函数没有意义，因为创建对象的线程在构造时应该可以访问它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tasks are submitted to the pool via an internal queue, which holds extra tasks whenever there are more active tasks than threads.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T063904Z" creationid="Admin" creationdate="20170630T063904Z">
        <seg>需要执行的任务通过一个内部队列提交给线程，当没有更多的工作线程可以用来执行任务时，队列保存额外的任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, a &lt;c5&gt;set&lt;/c5&gt; has a happens-before relationship with any subsequent &lt;c6&gt;get&lt;/c6&gt; on the same variable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T072817Z" creationid="Admin" creationdate="20170630T072817Z">
        <seg>就是说，同一变量上的一个  &lt;c5&gt;set&lt;/c5&gt;  操作对于任意后续的  &lt;c6&gt;get&lt;/c6&gt;  操作存在 happens-before 关系。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;a0&gt;&lt;c1&gt;&lt;c2&gt;SleepMessages&lt;/c2&gt;&lt;/c1&gt;&lt;/a0&gt; example uses &lt;c3&gt;sleep&lt;/c3&gt; to print messages at four-second intervals:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T071755Z" creationid="Admin" creationdate="20170622T071755Z">
        <seg>&lt;a0&gt;&lt;c1&gt;&lt;c2&gt;SleepMessages&lt;/c2&gt;&lt;/c1&gt;&lt;/a0&gt;示例中使用&lt;c3&gt;sleep&lt;/c3&gt;每隔4秒来打印消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;a0&gt;&lt;c1&gt;Executor&lt;/c1&gt;&lt;/a0&gt; interface provides a single method, &lt;c2&gt;execute&lt;/c2&gt;, designed to be a drop-in replacement for a common thread-creation idiom.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T030832Z" creationid="Admin" creationdate="20170630T030832Z">
        <seg>&lt;a0&gt;&lt;c1&gt;Executor&lt;/c1&gt;&lt;/a0&gt; 提供一个简单的&lt;c2&gt;execute&lt;/c2&gt;方法，用来替代通常创建线程的做法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;a0&gt;&lt;c1&gt;ExecutorService&lt;/c1&gt;&lt;/a0&gt; interface supplements &lt;c2&gt;execute&lt;/c2&gt; with a similar, but more versatile &lt;c3&gt;submit&lt;/c3&gt; method.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T062241Z" creationid="Admin" creationdate="20170630T062241Z">
        <seg>&lt;a0&gt;&lt;c1&gt;ExecutorService&lt;/c1&gt;&lt;/a0&gt; 接口相似地提供了&lt;c2&gt;execute&lt;/c2&gt; ，并且更通用地提供了 &lt;c3&gt;submit&lt;/c3&gt; 方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;a0&gt;&lt;c1&gt;ScheduledExecutorService&lt;/c1&gt;&lt;/a0&gt; interface supplements the methods of its parent &lt;c2&gt;ExecutorService&lt;/c2&gt; with &lt;c3&gt;schedule&lt;/c3&gt;, which executes a &lt;c4&gt;Runnable&lt;/c4&gt; or &lt;c5&gt;Callable&lt;/c5&gt; task after a specified delay.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T063041Z" creationid="Admin" creationdate="20170630T063041Z">
        <seg>&lt;a0&gt;&lt;c1&gt;ScheduledExecutorService&lt;/c1&gt;&lt;/a0&gt; 扩展了 &lt;c2&gt;ExecutorService&lt;/c2&gt; 接口，并添加了 &lt;c3&gt;schedule&lt;/c3&gt; 方法，它在指定的延时后执行一个 &lt;c4&gt;Runnable&lt;/c4&gt; 或 &lt;c5&gt;Callable&lt;/c5&gt; 任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;a0&gt;&lt;c1&gt;java.util.concurrent.atomic&lt;/c1&gt;&lt;/a0&gt; package defines classes that support atomic operations on single variables.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T072702Z" creationid="Admin" creationdate="20170630T072702Z">
        <seg>&lt;a0&gt;&lt;c1&gt;java.util.concurrent.atomic&lt;/c1&gt;&lt;/a0&gt; 包定义了对单一变量进行原子操作的类。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;a0&gt;&lt;c1&gt;newCachedThreadPool&lt;/c1&gt;&lt;/a0&gt; method creates an executor with an expandable thread pool.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T064611Z" creationid="Admin" creationdate="20170630T064611Z">
        <seg>&lt;a0&gt;&lt;c1&gt;newCachedThreadPool&lt;/c1&gt;&lt;/a0&gt; 创建一个具有可扩展线程池的执行器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;a0&gt;&lt;c1&gt;newSingleThreadExecutor&lt;/c1&gt;&lt;/a0&gt; method creates an executor that executes a single task at a time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T064706Z" creationid="Admin" creationdate="20170630T064706Z">
        <seg>&lt;a0&gt;&lt;c1&gt;newSingleThreadExecutor&lt;/c1&gt;&lt;/a0&gt; 创建一个执行单个任务的执行器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;Executor&lt;/c0&gt; Interface</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T030701Z" creationid="Admin" creationdate="20170630T030701Z">
        <seg>&lt;c0&gt;Executor&lt;/c0&gt; 接口</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;ExecutorService&lt;/c0&gt; Interface</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T062121Z" creationid="Admin" creationdate="20170630T062121Z">
        <seg>&lt;c0&gt;ExecutorService&lt;/c0&gt; 接口</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;MessageLoop&lt;/c0&gt; thread prints out a series of messages.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T080555Z" creationid="Admin" creationdate="20170622T080555Z">
        <seg>&lt;c0&gt;MessageLoop&lt;/c0&gt;  线程打印出一系列消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;ScheduledExecutorService&lt;/c0&gt; Interface</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T062918Z" creationid="Admin" creationdate="20170630T062918Z">
        <seg>&lt;c0&gt;ScheduledExecutorService&lt;/c0&gt; 接口</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;Thread&lt;/c0&gt; class defines a number of methods useful for thread management.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T065519Z" creationid="Admin" creationdate="20170622T065519Z">
        <seg>&lt;c0&gt;Thread&lt;/c0&gt; 类定义了大量的方法用于线程管理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;counter&lt;/c0&gt; field is shared between two threads, A and B. Suppose thread A increments &lt;c1&gt;counter&lt;/c1&gt;:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T092129Z" creationid="Admin" creationdate="20170622T092129Z">
        <seg>该&lt;c0&gt;counter&lt;/c0&gt; 字段由两个线程共享：A 和 B。假定线程 A 对 &lt;c1&gt;counter&lt;/c1&gt;进行自增操作：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;java.util.concurrent&lt;/c0&gt; package defines three executor interfaces:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T030341Z" creationid="Admin" creationdate="20170630T030341Z">
        <seg>&lt;c0&gt;java.util.concurrent&lt;/c0&gt; 包中定义了三个执行器接口：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;java.util.concurrent&lt;/c0&gt; package includes a number of additions to the Java Collections Framework.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T071946Z" creationid="Admin" creationdate="20170630T071946Z">
        <seg>&lt;c0&gt;java.util.concurrent&lt;/c0&gt; 包囊括了 Java 集合框架的一些附加类。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;join&lt;/c0&gt; method allows one thread to wait for the completion of another.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T075601Z" creationid="Admin" creationdate="20170622T075601Z">
        <seg>&lt;c0&gt;join&lt;/c0&gt; 方法允许一个线程等待另一个完成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c1&gt;sleep&lt;/c1&gt; method can also be used for pacing, as shown in the example that follows, and waiting for another thread with duties that are understood to have time requirements, as with the &lt;c2&gt;SimpleThreads&lt;/c2&gt; example in a later section.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T071037Z" creationid="Admin" creationdate="20170622T071037Z">
        <seg>&lt;c1&gt;sleep&lt;/c1&gt; 方法可以用来起搏，如下面的例子所示。也可以用来等待其他有时间要求的线程，如再下面的&lt;c2&gt;SimpleThreads&lt;/c2&gt; 例子所示。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c1&gt;tryLock&lt;/c1&gt; method backs out if the lock is not available immediately or before a timeout expires (if specified).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T024556Z" creationid="Admin" creationdate="20170630T024556Z">
        <seg>如果当前锁对象不可用，或者锁请求超时（如果超时时间已指定），&lt;c1&gt;tryLock&lt;/c1&gt; 方法会收回获取锁的请求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c2&gt;lockInterruptibly&lt;/c2&gt; method backs out if another thread sends an interrupt before the lock is acquired.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T024626Z" creationid="Admin" creationdate="20170630T024626Z">
        <seg>如果在锁获取前，另一个线程发送了一个中断，&lt;c2&gt;lockInterruptibly&lt;/c2&gt; 方法也会收回获取锁的请求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c5&gt;Runnable&lt;/c5&gt; object is passed to the &lt;c6&gt;Thread&lt;/c6&gt; constructor, as in the &lt;a7&gt;&lt;c8&gt;&lt;c9&gt;HelloRunnable&lt;/c9&gt;&lt;/c8&gt;&lt;/a7&gt; example:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T063222Z" creationid="Admin" creationdate="20170622T063222Z">
        <seg>&lt;c5&gt;Runnable&lt;/c5&gt; 对象传递给 &lt;c6&gt;Thread&lt;/c6&gt; 的构造方法，如&lt;a7&gt;&lt;c8&gt;&lt;c9&gt;HelloRunnable&lt;/c9&gt;&lt;/c8&gt;&lt;/a7&gt; 的示例：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c9&gt;submit&lt;/c9&gt; method returns a &lt;a10&gt;&lt;c11&gt;Future&lt;/c11&gt;&lt;/a10&gt; object, which is used to retrieve the &lt;c12&gt;Callable&lt;/c12&gt; return value and to manage the status of both &lt;c13&gt;Callable&lt;/c13&gt; and &lt;c14&gt;Runnable&lt;/c14&gt; tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T062516Z" creationid="Admin" creationdate="20170630T062516Z">
        <seg>&lt;c9&gt;submit&lt;/c9&gt; 方法返回一个 &lt;a10&gt;&lt;c11&gt;Future&lt;/c11&gt;&lt;/a10&gt; 对象，可以用来读取 &lt;c12&gt;Callable&lt;/c12&gt; 返回的结果，或者管理 &lt;c13&gt;Callable&lt;/c13&gt; 和 &lt;c14&gt;Runnable&lt;/c14&gt; 任务的状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Interrupt Status Flag</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T075049Z" creationid="Admin" creationdate="20170622T075049Z">
        <seg>中断状态标志</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Java platform is designed from the ground up to support concurrent programming, with basic concurrency support in the Java programming language and the Java class libraries.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T033025Z" creationid="Admin" creationdate="20170622T033025Z">
        <seg>Java平台从根本上设计为支持并发编程，在Java编程语言和Java类库中有基本的并发支持。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Java programming language provides two basic synchronization idioms: &lt;i0&gt;synchronized methods&lt;/i0&gt; and &lt;i1&gt;synchronized statements&lt;/i1&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T094958Z" creationid="Admin" creationdate="20170622T094958Z">
        <seg>Java 编程语言中提供了两种基本的同步语法： &lt;i0&gt;同步方法（synchronized methods）&lt;/i0&gt; 和 &lt;i1&gt;同步代码块（synchronized statements）&lt;/i1&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Java™ Tutorials</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T075902Z" creationid="Admin" creationdate="20170630T075902Z">
        <seg>Java教程</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The SimpleThreads Example</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T080306Z" creationid="Admin" creationdate="20170622T080306Z">
        <seg>SimpleThreads 示例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The application should print out "Mares do eat oats." Is it guaranteed to always do this?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T074041Z" creationid="Admin" creationdate="20170630T074041Z">
        <seg>应用程序应打印出“Mares do eat oats.”。 是否保证永远这样做？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The atomic &lt;c7&gt;compareAndSet&lt;/c7&gt; method also has these memory consistency features, as do the simple atomic arithmetic methods that apply to integer atomic variables.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T072848Z" creationid="Admin" creationdate="20170630T072848Z">
        <seg>原子的 &lt;c7&gt;compareAndSet&lt;/c7&gt; 方法也有内存一致性特点，就像应用到整型原子变量中的简单原子算法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The biggest advantage of &lt;c0&gt;Lock&lt;/c0&gt; objects over implicit locks is their ability to back out of an attempt to acquire a lock.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T024514Z" creationid="Admin" creationdate="20170630T024514Z">
        <seg>&lt;c0&gt;Lock&lt;/c0&gt; 对象之于隐式锁最大的优势在于，它们有能力收回获得锁的尝试。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The blurred &lt;i1&gt;destination&lt;/i1&gt; image is also represented by an integer array with the same size as the source.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T070433Z" creationid="Admin" creationdate="20170630T070433Z">
        <seg>与 source 图片相同，模糊之后的 &lt;i1&gt;destination&lt;/i1&gt;图片也由一个整数数组表示。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The causes of memory consistency errors are complex and beyond the scope of this tutorial.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T091807Z" creationid="Admin" creationdate="20170622T091807Z">
        <seg>导致内存一致性错误的原因很复杂，超出了本教程的描述范围。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The center of the fork/join framework is the &lt;a0&gt;&lt;c1&gt;ForkJoinPool&lt;/c1&gt;&lt;/a0&gt; class, an extension of the &lt;c2&gt;AbstractExecutorService&lt;/c2&gt; class.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T065528Z" creationid="Admin" creationdate="20170630T065528Z">
        <seg>fork/join 框架的核心是 &lt;a0&gt;&lt;c1&gt;ForkJoinPool&lt;/c1&gt;&lt;/a0&gt; 类，它是对 &lt;c2&gt;AbstractExecutorService&lt;/c2&gt; 类的扩展。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The class itself is declared &lt;c0&gt;final&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170626T024910Z" creationid="Admin" creationdate="20170626T024910Z">
        <seg>类本身被声明为&lt;c0&gt; final &lt;/c0&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The class, &lt;a0&gt;&lt;c1&gt;&lt;c2&gt;SynchronizedRGB&lt;/c2&gt;&lt;/c1&gt;&lt;/a0&gt;, defines objects that represent colors.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T100531Z" creationid="Admin" creationdate="20170623T100531Z">
        <seg>&lt;a0&gt;&lt;c1&gt;&lt;c2&gt;SynchronizedRGB&lt;/c2&gt;&lt;/c1&gt;&lt;/a0&gt;类定义了一个表示颜色的类。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The consumer thread, defined in &lt;a0&gt;&lt;c1&gt;&lt;c2&gt;Consumer&lt;/c2&gt;&lt;/c1&gt;&lt;/a0&gt;, simply retrieves the messages and prints them out, until it retrieves the "DONE" string.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T094506Z" creationid="Admin" creationdate="20170623T094506Z">
        <seg>&lt;a0&gt;&lt;c1&gt;&lt;c2&gt;Consumer&lt;/c2&gt;&lt;/c1&gt;&lt;/a0&gt;中定义的消费者线程，简单地读取消息并打印出来，直到读取到字符串“DONE”。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The effects of the code in the thread are now visible to the thread that performed the join.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T092840Z" creationid="Admin" creationdate="20170622T092840Z">
        <seg>也就是说终止了的线程中的代码效果对调用 join 方法的线程来说是可见。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The effects of the code that led up to the creation of the new thread are visible to the new thread.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T092721Z" creationid="Admin" creationdate="20170622T092721Z">
        <seg>引入并创建这个新线程的代码产生的结果对该新线程来说都是可见的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The executor implementations in &lt;c0&gt;java.util.concurrent&lt;/c0&gt; are designed to make full use of the more advanced &lt;c1&gt;ExecutorService&lt;/c1&gt; and &lt;c2&gt;ScheduledExecutorService&lt;/c2&gt; interfaces, although they also work with the base &lt;c3&gt;Executor&lt;/c3&gt; interface.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T062113Z" creationid="Admin" creationdate="20170630T062113Z">
        <seg>&lt;c0&gt; java.util.concurrent &lt;/c0&gt;中p实现的执行器旨在充分利用更高级的&lt;c1&gt; ExecutorService &lt;/c1&gt;和&lt;c2&gt; ScheduledExecutorService &lt;/c2&gt;接口，尽管它们也可以使用基本的&lt;c3&gt;Executor&lt;/c3&gt;接口。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The expression &lt;c0&gt;c--&lt;/c0&gt; can be decomposed the same way, except that the second step decrements instead of increments.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T090828Z" creationid="Admin" creationdate="20170622T090828Z">
        <seg>表达式 &lt;c0&gt;c--&lt;/c0&gt; 也是会被按照同样的方式进行翻译，只不过第二步变成了减1，而不是加1。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first idiom, which employs a &lt;c0&gt;Runnable&lt;/c0&gt; object, is more general, because the &lt;c1&gt;Runnable&lt;/c1&gt; object can subclass a class other than &lt;c2&gt;Thread&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T063921Z" creationid="Admin" creationdate="20170622T063921Z">
        <seg>第一种方式,它使用 &lt;c0&gt;Runnable&lt;/c0&gt; 对象,在实际应用中更普遍,因为&lt;c1&gt;Runnable&lt;/c1&gt;对象可以继承&lt;c2&gt;Thread&lt;/c2&gt; 以外的类。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first is the main thread that every Java application has.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T080356Z" creationid="Admin" creationdate="20170622T080356Z">
        <seg>第一个线程是每个 Java 应用程序都有主线程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first one, &lt;c0&gt;set&lt;/c0&gt;, arbitrarily transforms the object, and has no place in an immutable version of the class.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170626T030242Z" creationid="Admin" creationdate="20170626T024711Z">
        <seg>第一个，&lt;c0&gt; set &lt;/c0&gt;，它任意地改这个对象，并且在该类的不可变版本中没有位置（译注：应该就是不需要的意思）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first step for using the fork/join framework is to write code that performs a segment of the work.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T065736Z" creationid="Admin" creationdate="20170630T065736Z">
        <seg>使用 fork/join 框架的第一步是编写执行一部分工作的代码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example brings together some of the concepts of this section.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T080335Z" creationid="Admin" creationdate="20170622T080335Z">
        <seg>以下示例汇集了本课程的一些概念。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following rules define a simple strategy for creating immutable objects.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170626T021953Z" creationid="Admin" creationdate="20170626T021953Z">
        <seg>以下规则定义了创建不可变对象的简单策略。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following subsections describe executors in detail.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T025933Z" creationid="Admin" creationdate="20170630T025933Z">
        <seg>接下来的部分将讲详细描述执行器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following subsections take a class whose instances are mutable and derives a class with immutable instances from it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T100239Z" creationid="Admin" creationdate="20170623T100239Z">
        <seg>接下来看一个可变对象的类，然后转化为一个不可变对象的类。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The fork/join framework is an implementation of the &lt;c0&gt;ExecutorService&lt;/c0&gt; interface that helps you take advantage of multiple processors.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T065121Z" creationid="Admin" creationdate="20170630T065121Z">
        <seg>框架是  &lt;c0&gt;ExecutorService&lt;/c0&gt;  接口的一种具体实现，目的是为了帮助你更好地利用多处理器带来的好处。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The fork/join framework is distinct because it uses a &lt;i1&gt;work-stealing&lt;/i1&gt; algorithm.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T065406Z" creationid="Admin" creationdate="20170630T065406Z">
        <seg>fork/join 框架的独特之处在与它使用&lt;i1&gt;工作窃取（work-stealing）&lt;/i1&gt;算法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The goal is to use all the available processing power to enhance the performance of your application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T065220Z" creationid="Admin" creationdate="20170630T065220Z">
        <seg>目标是使用所有可用的处理能力来提高应用程序的性能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The impact of object creation is often overestimated, and can be offset by some of the efficiencies associated with immutable objects.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T100123Z" creationid="Admin" creationdate="20170623T100123Z">
        <seg>实际上这种开销常常被过分高估，而且使用不可变对象所带来的一些效率提升也抵消了这种开销。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The interrupt mechanism is implemented using an internal flag known as the &lt;i0&gt;interrupt status&lt;/i0&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T075128Z" creationid="Admin" creationdate="20170622T075128Z">
        <seg>中断机制使用被称为 &lt;i0&gt;interrupt status&lt;/i0&gt;的内部标志来实现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The invocation of &lt;c2&gt;wait&lt;/c2&gt; does not return until another thread has issued a notification that some special event may have occurred  though not necessarily the event this thread is waiting for:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T090932Z" creationid="Admin" creationdate="20170623T090932Z">
        <seg>调用 &lt;c2&gt;wait&lt;/c2&gt; 不会返回，直到另一线程发出一个可能发生的特殊事件的通知——尽管通知的事件不一定是这个线程正在等待的事件：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The key to avoiding memory consistency errors is understanding the &lt;i0&gt;happens-before&lt;/i0&gt; relationship.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T091928Z" creationid="Admin" creationdate="20170622T091928Z">
        <seg>避免出现内存一致性错误的关键在于理解&lt;i0&gt;happens-before&lt;/i0&gt; 关系。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The lock release occurs even if the return was caused by an uncaught exception.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T063731Z" creationid="Admin" creationdate="20170623T063731Z">
        <seg>即使是由于出现了没有被捕获的异常而导致方法返回，该锁也会被释放。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The low-level idiom creates a new thread and launches it immediately.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T031356Z" creationid="Admin" creationdate="20170630T031356Z">
        <seg>低级的方法是创一个线程并立即启动。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The main thread creates a new thread from the &lt;c2&gt;Runnable&lt;/c2&gt; object, &lt;c3&gt;MessageLoop&lt;/c3&gt;, and waits for it to finish.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T080520Z" creationid="Admin" creationdate="20170622T080520Z">
        <seg>主线程从&lt;c2&gt; Runnable &lt;/c2&gt;对象，&lt;c3&gt; MessageLoop &lt;/c3&gt;，创建一个新线程，并等待它完成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The more complex of the two, synchronized statements, are described in the next section.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T095014Z" creationid="Admin" creationdate="20170622T095014Z">
        <seg>两者中同步代码块相对而言更为复杂一些，我们将在下一小节中进行描述。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The most common coordination idiom is the &lt;i0&gt;guarded block&lt;/i0&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T083446Z" creationid="Admin" creationdate="20170623T083424Z">
        <seg>最常见的方式是使用 &lt;i0&gt;guarded block&lt;/i0&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The non-static &lt;c3&gt;isInterrupted&lt;/c3&gt; method, which is used by one thread to query the interrupt status of another, does not change the interrupt status flag.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T075256Z" creationid="Admin" creationdate="20170622T075256Z">
        <seg>非静态 &lt;c3&gt;isInterrupted&lt;/c3&gt;方法，它是用于线程来查询另一个线程的中断状态，不会改变中断状态标志</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The original &lt;i0&gt;source&lt;/i0&gt; image is represented by an array of integers, where each integer contains the color values for a single pixel.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T070402Z" creationid="Admin" creationdate="20170630T070402Z">
        <seg>原始的 &lt;i0&gt;source&lt;/i0&gt; 图片由一个整数的数组表示，每个整数表示一个像素点的颜色数值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The other methods are invoked from other threads involved in managing the thread and &lt;c2&gt;Thread&lt;/c2&gt; object.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T070031Z" creationid="Admin" creationdate="20170622T070031Z">
        <seg>其他方法是从涉及管理线程和&lt;c2&gt;线程&lt;/c2&gt;对象的其他线程调用的。 </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The other thread will block when it attempts to acquire the lock.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T063415Z" creationid="Admin" creationdate="20170623T063415Z">
        <seg>其他线程在尝试获取该锁时将被阻塞。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The producer thread, defined in &lt;a0&gt;&lt;c1&gt;&lt;c2&gt;Producer&lt;/c2&gt;&lt;/c1&gt;&lt;/a0&gt;, sends a series of familiar messages.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T093851Z" creationid="Admin" creationdate="20170623T093851Z">
        <seg>&lt;a0&gt;&lt;c1&gt;&lt;c2&gt;Producer&lt;/c2&gt;&lt;/c1&gt;&lt;/a0&gt;中定义的生产者线程，发送一系列相似的消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second idiom is easier to use in simple applications, but is limited by the fact that your task class must be a descendant of &lt;c3&gt;Thread&lt;/c3&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T063952Z" creationid="Admin" creationdate="20170622T063952Z">
        <seg>第二种方式，在简单的应用程序更容易使用,但受限于你的任务类必须是一个 &lt;c3&gt;Thread&lt;/c3&gt;的后代。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second one, &lt;c1&gt;invert&lt;/c1&gt;, can be adapted by having it create a new object instead of modifying the existing one.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170626T024820Z" creationid="Admin" creationdate="20170626T024820Z">
        <seg>第二个&lt;c1&gt; invert &lt;/c1&gt;可以调整为：通过创建一个新对象而不是修改现有对象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The simplest way to do this is to declare the class as &lt;c0&gt;final&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170626T022355Z" creationid="Admin" creationdate="20170626T022355Z">
        <seg>简单的方法是将该类申明为&lt;c0&gt;final&lt;/c0&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The standard general-purpose implementation of &lt;c3&gt;ConcurrentNavigableMap&lt;/c3&gt; is &lt;a4&gt;&lt;c5&gt;ConcurrentSkipListMap&lt;/c5&gt;&lt;/a4&gt;, which is a concurrent analog of &lt;a6&gt;&lt;c7&gt;TreeMap&lt;/c7&gt;&lt;/a6&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T072450Z" creationid="Admin" creationdate="20170630T072450Z">
        <seg>&lt;c3&gt;ConcurrentNavigableMap&lt;/c3&gt; 的标准的一般目的的实现是 &lt;a4&gt;&lt;c5&gt;ConcurrentSkipListMap&lt;/c5&gt;&lt;/a4&gt;，它是 &lt;a6&gt;&lt;c7&gt;TreeMap&lt;/c7&gt;&lt;/a6&gt;的并发模式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The standard general-purpose implementation of &lt;c4&gt;ConcurrentMap&lt;/c4&gt; is &lt;a5&gt;&lt;c6&gt;ConcurrentHashMap&lt;/c6&gt;&lt;/a5&gt;, which is a concurrent analog of &lt;a7&gt;&lt;c8&gt;HashMap&lt;/c8&gt;&lt;/a7&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T072310Z" creationid="Admin" creationdate="20170630T072310Z">
        <seg>&lt;c4&gt;ConcurrentMap&lt;/c4&gt; 的标准的一般目的的实现是 &lt;a5&gt;&lt;c6&gt;ConcurrentHashMap&lt;/c6&gt;&lt;/a5&gt;，它是&lt;a7&gt;&lt;c8&gt;HashMap&lt;/c8&gt;&lt;/a7&gt;的并发模式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The string "DONE" indicates that all messages have been sent.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T093920Z" creationid="Admin" creationdate="20170623T093920Z">
        <seg>字符串“DONE”表示所有消息都已经发送。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The tool needed to prevent these errors is &lt;i2&gt;synchronization&lt;/i2&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T083321Z" creationid="Admin" creationdate="20170622T083321Z">
        <seg>防止这些错误所需的工具是&lt;i2&gt;synchronization&lt;/i2&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The two threads communicate using a shared object.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T093341Z" creationid="Admin" creationdate="20170623T093341Z">
        <seg>两个线程使用共享对象进行通信。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Then it might be modified as follows to support interrupts:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T074635Z" creationid="Admin" creationdate="20170622T074635Z">
        <seg>那么可能会如下修改以支持中断：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Then it must periodically invoke &lt;c1&gt;Thread.interrupted&lt;/c1&gt;, which returns &lt;c2&gt;true&lt;/c2&gt; if an interrupt has been received.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T074902Z" creationid="Admin" creationdate="20170622T074902Z">
        <seg>那么它必须定期调用 &lt;c1&gt;Thread.interrupted&lt;/c1&gt;，在收到中断后，它会返回&lt;c2&gt;true&lt;/c2&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Then, shortly afterwards, thread B prints out &lt;c0&gt;counter&lt;/c0&gt;:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T092206Z" creationid="Admin" creationdate="20170622T092206Z">
        <seg>然后，不久之后，线程B打印&lt;c0&gt;counter&lt;/c0&gt;的值：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are a number of steps to follow in order to do this correctly.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T090001Z" creationid="Admin" creationdate="20170623T090001Z">
        <seg>为了正确执行，需要遵循以下步骤。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are also new concurrent data structures in the Java Collections Framework.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T023124Z" creationid="Admin" creationdate="20170630T023124Z">
        <seg>Java 集合框架中也定义了新的并发数据结构。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are several actions that create happens-before relationships.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T092444Z" creationid="Admin" creationdate="20170622T092444Z">
        <seg>我们可以采取多种方式建立这种 happens-before 关系。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are two basic strategies for using &lt;c2&gt;Thread&lt;/c2&gt; objects to create a concurrent application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T061747Z" creationid="Admin" creationdate="20170622T061747Z">
        <seg>有两种使用&lt;c2&gt;线程&lt;/c2&gt; 对象来创建并发应用程序的基本策略：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are two setter methods in this class.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170626T022902Z" creationid="Admin" creationdate="20170626T022902Z">
        <seg>访类中有两个set方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are two ways to do this:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T062832Z" creationid="Admin" creationdate="20170622T062832Z">
        <seg>有两种方式来这样做：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, no safeguards against changing the state of "contained" mutable objects are necessary.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170626T030025Z" creationid="Admin" creationdate="20170626T030025Z">
        <seg>因此，不能改变“包含”可变对象的状态的保障措施是必要的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These APIs are adequate for very basic tasks, but higher-level building blocks are needed for more advanced tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T022612Z" creationid="Admin" creationdate="20170630T022612Z">
        <seg>这些API 对于非常基本的任务来说已经足够，但是对于更高级的任务就需要更高级的 API。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These are most easily categorized by the collection interfaces provided:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T072010Z" creationid="Admin" creationdate="20170630T072010Z">
        <seg>它们也最容易按照集合类所提供的接口来进行分类：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These include &lt;c1&gt;static&lt;/c1&gt; methods, which provide information about, or affect the status of, the thread invoking the method.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T065907Z" creationid="Admin" creationdate="20170622T065907Z">
        <seg>包括一些 &lt;c1&gt;static&lt;/c1&gt; 方法，它们提供有关调用该方法的线程的信息或影响线程的状态。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These include decreased overhead due to garbage collection, and the elimination of code needed to protect mutable objects from corruption.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T100205Z" creationid="Admin" creationdate="20170623T100205Z">
        <seg>例如：使用不可变对象降低了垃圾回收所产生的额外开销，也减少了用来确保使用可变对象不出现并发错误的一些额外代码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These methods are similar to &lt;c4&gt;sort()&lt;/c4&gt;, but leverage concurrency via the fork/join framework.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T071627Z" creationid="Admin" creationdate="20170630T071627Z">
        <seg>这些方法类似于&lt;c4&gt;sort()&lt;/c4&gt;，但是通过fork/join框架来利用并发性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These operations remove or replace a key-value pair only if the key is present, or add a key-value pair only if the key is absent.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T072154Z" creationid="Admin" creationdate="20170630T072154Z">
        <seg>移除或者替换键值对的操作只有当 key 存在时才能进行，而新增操作只有当 key 不存在时。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They assume that they can continue to work in a word processor, while other applications download files, manage the print queue, and stream audio.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T032356Z" creationid="Admin" creationdate="20170622T032356Z">
        <seg>他们假设他们可以继续在文字处理器中工作，而其他应用程序下载文件，管理打印队列和流音频。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They're still blocking each other, so...</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T082247Z" creationid="Admin" creationdate="20170623T082247Z">
        <seg>他们仍然阻止对方，所以...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This allows interrupt handling code to be centralized in a &lt;c0&gt;catch&lt;/c0&gt; clause.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T075039Z" creationid="Admin" creationdate="20170622T075039Z">
        <seg>这允许中断处理代码集中在一个&lt;c0&gt; catch &lt;/c0&gt;子句中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This depends on what it's currently doing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T074218Z" creationid="Admin" creationdate="20170622T074218Z">
        <seg>这取决于它当前在做什么。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This describes a situation where synchronized code, directly or indirectly, invokes a method that also contains synchronized code, and both sets of code use the same lock.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T071701Z" creationid="Admin" creationdate="20170623T071701Z">
        <seg>它是这样的一种情况：在同步代码中直接或者间接地调用了还有同步代码的方法，两个同步代码段中使用的是同一个锁。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This does not necessarily mean the creators of these classes were sloppy  they may have good reason for believing that instances of their classes never change after construction.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170626T022125Z" creationid="Admin" creationdate="20170626T022125Z">
        <seg>不过这不是编写这些类的程序员们粗心大意造成的，很可能的是他们有充分的理由确保这些对象在创建后不会被修改。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example application, &lt;a0&gt;&lt;c1&gt;&lt;c2&gt;Deadlock&lt;/c2&gt;&lt;/c1&gt;&lt;/a0&gt;, models this possibility:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T074847Z" creationid="Admin" creationdate="20170623T074847Z">
        <seg>这个示例应用程序中， &lt;a0&gt;&lt;c1&gt;&lt;c2&gt;死锁&lt;/c2&gt;&lt;/c1&gt;&lt;/a0&gt;模型是这样的：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This executor is suitable for applications that launch many short-lived tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T064646Z" creationid="Admin" creationdate="20170630T064646Z">
        <seg>这个执行器适用于会启动许多短暂任务的应用程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This form of communication is extremely efficient, but makes two kinds of errors possible: &lt;i0&gt;thread interference&lt;/i0&gt; and &lt;i1&gt;memory consistency errors&lt;/i1&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T083021Z" creationid="Admin" creationdate="20170622T083021Z">
        <seg>这种形式的通信是非常有效的，但可能导致2种可能的错误：线程干扰（ &lt;i0&gt;thread interference&lt;/i0&gt;）和内存一致性错误（ &lt;i1&gt;memory consistency errors&lt;/i1&gt;）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This greatly enhances a system's capacity for concurrent execution of processes and threads  but concurrency is possible even on simple systems, without multiple processors or execution cores.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T034800Z" creationid="Admin" creationdate="20170622T034800Z">
        <seg>这大大增强了系统的进程和线程的并发执行能力。但即便是没有多处理器或多进程的系统中，并发仍然是可能的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This guarantees that changes to the state of the object are visible to all threads.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T101732Z" creationid="Admin" creationdate="20170622T101732Z">
        <seg>这就确保了对该对象的修改对其他线程是可见的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This happens when shared resources are made unavailable for long periods by "greedy" threads.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T075956Z" creationid="Admin" creationdate="20170623T075956Z">
        <seg>这种情况一般出现在共享资源被某些“贪婪”线程占用，而导致资源长时间不能被其他线程可用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is an efficient means of making processor time available to the other threads of an application or other applications that might be running on a computer system.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T070802Z" creationid="Admin" creationdate="20170622T070802Z">
        <seg>这是使处理器时间可用于应用程序的其他线程或可能在计算机系统上运行的其他应用程序的有效手段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is an exception that &lt;c2&gt;sleep&lt;/c2&gt; throws when another thread interrupts the current thread while &lt;c3&gt;sleep&lt;/c3&gt; is active.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T072340Z" creationid="Admin" creationdate="20170622T072340Z">
        <seg>当&lt;c3&gt; sleep &lt;/c3&gt;处于活动状态时，另一个线程中断当前线程时，&lt;c2&gt; sleep &lt;/c2&gt;将抛出异常。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is comparable to two people attempting to pass each other in a corridor: Alphonse moves to his left to let Gaston pass, while Gaston moves to his right to let Alphonse pass.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T082129Z" creationid="Admin" creationdate="20170623T082129Z">
        <seg>现实中的例子是，两人面对面试图通过一条走廊：Alphonse 移动到他的左则让路给 Gaston ，而 Gaston 移动到他的右侧想让 Alphonse 过去。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is especially true for massively concurrent applications that fully exploit today's multiprocessor and multi-core systems.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T022710Z" creationid="Admin" creationdate="20170630T022710Z">
        <seg>对于充分利用当今多处理器和多核系统的大规模并发应用程序尤其如此。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is the usage emphasized in this lesson.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T072842Z" creationid="Admin" creationdate="20170622T072842Z">
        <seg>这是本课中强调的使用方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is true even in systems that only have a single execution core, and thus only have one thread actually executing at any given moment.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T034604Z" creationid="Admin" creationdate="20170622T034604Z">
        <seg>实际上，在给定的时间内，每个处理器只能有一个线程得到真正的运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This kind of application shares data between two threads: the &lt;i1&gt;producer&lt;/i1&gt;, that creates the data, and the &lt;i2&gt;consumer&lt;/i2&gt;, that does something with it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T093324Z" creationid="Admin" creationdate="20170623T093324Z">
        <seg>这类应用需要在两个线程之间共享数据： &lt;i1&gt;生产者（producer）&lt;/i1&gt;生产数据，&lt;i2&gt;消费者（consumer）&lt;/i2&gt;使用数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This kind of inconsistency is only possible for mutable objects  it will not be an issue for the immutable version of &lt;c0&gt;SynchronizedRGB&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T101245Z" creationid="Admin" creationdate="20170623T101228Z">
        <seg>这种不一致的问题只可能发生在可变对象上——在不可变对象版本的&lt;c0&gt;SynchronizedRGB&lt;/c0&gt;上，这将不是问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This kind of lock is easy to use, but has many limitations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T024036Z" creationid="Admin" creationdate="20170630T024036Z">
        <seg>这种锁是易于使用，但有许多限制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This kind of thread exists separately from the &lt;c3&gt;Runnable&lt;/c3&gt; and &lt;c4&gt;Callable&lt;/c4&gt; tasks it executes and is often used to execute multiple tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T063621Z" creationid="Admin" creationdate="20170630T063621Z">
        <seg>工作线程独立于所它所执行的  &lt;c3&gt;Runnable&lt;/c3&gt; 任务和 &lt;c4&gt;Callable&lt;/c4&gt; 任务，并且常用来执行多个任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This lesson focuses on the first approach, which separates the &lt;c4&gt;Runnable&lt;/c4&gt; task from the &lt;c5&gt;Thread&lt;/c5&gt; object that executes the task.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T064418Z" creationid="Admin" creationdate="20170622T064418Z">
        <seg>本课程推荐使用第一种方法,将 &lt;c4&gt;Runnable&lt;/c4&gt; 任务从 &lt;c5&gt;Thread&lt;/c5&gt; 对象中分离来执行任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This lesson introduces the platform's basic concurrency support and summarizes some of the high-level APIs in the &lt;c0&gt;java.util.concurrent&lt;/c0&gt; packages.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T033203Z" creationid="Admin" creationdate="20170622T033203Z">
        <seg>本课介绍了平台的基本并发支持，并总结了&lt;c0&gt;java.util.concurrent&lt;/c0&gt;包中的一些高级API。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This makes for efficient, but potentially problematic, communication.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T042157Z" creationid="Admin" creationdate="20170622T042157Z">
        <seg>这使得工作变得高效，但也存在了一个潜在的问题——通信。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that changes to a &lt;c2&gt;volatile&lt;/c2&gt; variable are always visible to other threads.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T073408Z" creationid="Admin" creationdate="20170623T073408Z">
        <seg>这就意味着对&lt;c2&gt;volatile&lt;/c2&gt; 类型变量的修改对于别的线程来说是可见的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that the two operations consist of multiple steps, and the sequences of steps overlap.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T084745Z" creationid="Admin" creationdate="20170622T084745Z">
        <seg>这就意味着操作是由多个步骤构成的，而此时，在这多个步骤的执行上出现了叠加。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This relationship is simply a guarantee that memory writes by one specific statement are visible to another specific statement.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T091946Z" creationid="Admin" creationdate="20170622T091946Z">
        <seg>这种关系是一种简单的方法，能够确保一条语句对内存的写操作对于其它特定的语句都是可见的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This section covers the following topics:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T083605Z" creationid="Admin" creationdate="20170622T083605Z">
        <seg>该部分涵盖以下主题：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This section describes the most common kind of liveness problem, &lt;a1&gt;deadlock&lt;/a1&gt;, and goes on to briefly describe two other liveness problems, &lt;a2&gt;starvation and livelock&lt;/a2&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T074219Z" creationid="Admin" creationdate="20170623T074219Z">
        <seg>本节将介绍最常见的一种活跃度的问题——&lt;a1&gt;死锁（deadlock）&lt;/a1&gt;，并且简要介绍另外两个活跃度问题&lt;a2&gt;饥饿（starvation）和活锁（livelock）&lt;/a2&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This section documents the use of &lt;c0&gt;Thread&lt;/c0&gt; objects.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T062107Z" creationid="Admin" creationdate="20170622T062107Z">
        <seg>本节介绍使用&lt;c0&gt;线程&lt;/c0&gt; 对象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This section is about synchronized methods.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T095025Z" creationid="Admin" creationdate="20170622T095025Z">
        <seg>本节重点讨论同步方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This thread also pauses for random intervals.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T094526Z" creationid="Admin" creationdate="20170623T094526Z">
        <seg>这个线程也会暂停随机的间隔。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This thread has the ability to create additional threads, as we'll demonstrate in the next section.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T042343Z" creationid="Admin" creationdate="20170622T042343Z">
        <seg>这个线程有能力创建额外的线程。正如我们将在下一部分展示的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This type of pool always has a specified number of threads running; if a thread is somehow terminated while it is still in use, it is automatically replaced with a new thread.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T063841Z" creationid="Admin" creationdate="20170630T063841Z">
        <seg>这种线程池始终有一定数量的线程在运行，如果一个线程由于某种原因终止运行了，线程池会自动创建一个新的线程来代替它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This works well for small applications, but in large-scale applications, it makes sense to separate thread management and creation from the rest of the application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T025828Z" creationid="Admin" creationdate="20170630T025828Z">
        <seg>但对于大规模并发应用来说，合理的做法是将线程的创建与管理和程序的其他部分分离开。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Though this is a general programming guide, its chapter on threads contains essential "best practices" for concurrent programming.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T073712Z" creationid="Admin" creationdate="20170630T073712Z">
        <seg>虽然这是常规的编程指南，但是它的线程章节包含了并发编程的基本“最佳实践”。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thread A's result is lost, overwritten by Thread B. This particular interleaving is only one possibility.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T091151Z" creationid="Admin" creationdate="20170622T091151Z">
        <seg>这样线程 A 计算的值就丢失了，也就是被线程 B 的值覆盖了。上面的这种“交错”只是其中的一种可能性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thread A: Increment retrieved value; result is 1.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T091053Z" creationid="Admin" creationdate="20170622T091053Z">
        <seg>Thread A: 对获取到的值加1；其结果是1。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thread A: Retrieve c.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T091126Z" creationid="Admin" creationdate="20170622T091126Z">
        <seg>Thread A: 获取 c 的值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thread A: Store result in c; c is now 1.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T091105Z" creationid="Admin" creationdate="20170622T091105Z">
        <seg>Thread A: 将结果存储到 c 中；此时c的值是1。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thread B: Decrement retrieved value; result is -1.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T091056Z" creationid="Admin" creationdate="20170622T091056Z">
        <seg>Thread B: 对获取到的值减1；其结果是-1。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thread B: Retrieve c.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T091129Z" creationid="Admin" creationdate="20170622T091129Z">
        <seg>Thread B: 获取 c 的值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thread B: Store result in c; c is now -1.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T091113Z" creationid="Admin" creationdate="20170622T091113Z">
        <seg>Thread B: 将结果存储到 c 中；此时c的值是-1。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thread Interference</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T084237Z" creationid="Admin" creationdate="20170622T084237Z">
        <seg>线程干扰</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thread Objects</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T042501Z" creationid="Admin" creationdate="20170622T042501Z">
        <seg>线程对象</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thread Pools</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T063313Z" creationid="Admin" creationdate="20170630T063313Z">
        <seg>线程池</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thread objects use a significant amount of memory, and in a large-scale application, allocating and deallocating many thread objects creates a significant memory management overhead.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T063750Z" creationid="Admin" creationdate="20170630T063750Z">
        <seg>在大规模并发应用中，创建大量的 Thread 对象会占用占用大量系统内存，分配和回收这些对象会产生很大的开销。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Threads</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T041922Z" creationid="Admin" creationdate="20170622T041922Z">
        <seg>线程</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Threads are sometimes called &lt;i0&gt;lightweight processes&lt;/i0&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T041943Z" creationid="Admin" creationdate="20170622T041943Z">
        <seg>线程有时被称为轻量级进程（ &lt;i0&gt;lightweight processes&lt;/i0&gt;）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Threads communicate primarily by sharing access to fields and the objects reference fields refer to.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T082919Z" creationid="Admin" creationdate="20170622T082919Z">
        <seg>线程间的通信主要是通过共享访问字段以及其字段所引用的对象来实现的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Threads exist within a process  every process has at least one.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T042051Z" creationid="Admin" creationdate="20170622T042051Z">
        <seg>线程中存在于进程中,每个进程都至少一个线程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Threads often have to coordinate their actions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T083412Z" creationid="Admin" creationdate="20170623T083412Z">
        <seg>多线程之间经常需要协同工作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Threads share the process's resources, including memory and open files.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T042102Z" creationid="Admin" creationdate="20170622T042102Z">
        <seg>线程共享进程的资源,包括内存和打开的文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus access to class's static fields is controlled by a lock that's distinct from the lock for any instance of the class.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T064235Z" creationid="Admin" creationdate="20170623T064235Z">
        <seg>因此，访问类的静态字段是由一个锁控制的，该锁与任何该类的实例的锁都不同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To abstract thread management from the rest of your application, pass the application's tasks to an &lt;i0&gt;executor&lt;/i0&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T061958Z" creationid="Admin" creationdate="20170622T061958Z">
        <seg>通过传递给应用程序任务给一个 &lt;i0&gt;executor&lt;/i0&gt;，从而从应用程序的其他部分抽象出线程管理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To avoid re-inventing the wheel, examine the existing data structures in the &lt;a2&gt;Java Collections Framework&lt;/a2&gt; before trying to code your own data-sharing objects.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T094854Z" creationid="Admin" creationdate="20170623T094854Z">
        <seg>为了避免重复造轮子，请在尝试编写自己的数据共享对象之前，先查看&lt;a2&gt; Java Collections Framework &lt;/a2&gt;中的现有数据结构。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To avoid this outcome, the two statements must be bound together:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T101143Z" creationid="Admin" creationdate="20170623T101143Z">
        <seg>为了避免出现这样的结果，必须要像把这两条语句绑定到一块执行：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To demonstrate the versatility of this idiom, we assume that Alphonse and Gaston are so infatuated with their newfound ability to bow safely that they can't stop bowing to each other:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T025114Z" creationid="Admin" creationdate="20170630T025114Z">
        <seg>为了说明这个成语的多功能性，我们假设Alphonse和Gaston如此迷恋着他们的新发现能力，安全地鞠躬，他们不能停止彼此的鞠躬。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To directly control thread creation and management, simply instantiate &lt;c0&gt;Thread&lt;/c0&gt; each time the application needs to initiate an asynchronous task.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T061932Z" creationid="Admin" creationdate="20170622T061932Z">
        <seg>为了直接控制线程的创建和管理，简单地初始化&lt;c0&gt;线程&lt;/c0&gt;，应用程序每次需要启动一个异步任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To facilitate communication between processes, most operating systems support &lt;i0&gt;Inter Process Communication&lt;/i0&gt; (IPC) resources, such as pipes and sockets.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T041759Z" creationid="Admin" creationdate="20170622T041759Z">
        <seg>大多数操作系统都支持进程间通信( &lt;i0&gt;Inter Process Communication&lt;/i0&gt; (IPC) 资源,如pipes 和 sockets。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To help you understand how the fork/join framework works, consider the following example.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T070317Z" creationid="Admin" creationdate="20170630T070317Z">
        <seg>想要了解 fork/join 框架的基本工作原理，接下来的这个例子会有所帮助。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To make a method synchronized, simply add the &lt;c0&gt;synchronized&lt;/c0&gt; keyword to its declaration:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T095117Z" creationid="Admin" creationdate="20170622T095117Z">
        <seg>要同步一个方法，简单地在方法声明中添加&lt;c0&gt;synchronized&lt;/c0&gt; 关键字即可：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To see how this package might be used, let's return to the &lt;a0&gt;&lt;c1&gt;&lt;c2&gt;Counter&lt;/c2&gt;&lt;/c1&gt;&lt;/a0&gt; class we originally used to demonstrate thread interference:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T072919Z" creationid="Admin" creationdate="20170630T072919Z">
        <seg>为了看看这个包如何使用，让我们返回到最初用于演示线程干扰的 &lt;a0&gt;&lt;c1&gt;&lt;c2&gt;Counter&lt;/c2&gt;&lt;/c1&gt;&lt;/a0&gt; 类：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To see this, consider the following example.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T091955Z" creationid="Admin" creationdate="20170622T091955Z">
        <seg>为了理解这点，我们可以考虑如下的示例。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To simulate the unpredictable nature of real-world applications, the producer thread pauses for random intervals between messages.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T094355Z" creationid="Admin" creationdate="20170623T094355Z">
        <seg>为了模拟现实情况，生产者线程还会在消息发送时随机的暂停。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To support immediate shutdown, tasks should handle &lt;a3&gt;interrupts&lt;/a3&gt; correctly.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T062912Z" creationid="Admin" creationdate="20170630T062912Z">
        <seg>要技持立即关闭，任务需要正确地处理 &lt;a3&gt;interrupts&lt;/a3&gt; 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To understand this, consider a web server application where each HTTP request is handled by a separate thread.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T064014Z" creationid="Admin" creationdate="20170630T064014Z">
        <seg>要理解这一点，例如一个 Web 服务器，每一个 HTTP 请求都是由一个单独的线程来处理的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Two overloaded versions of &lt;c0&gt;sleep&lt;/c0&gt; are provided: one that specifies the sleep time to the millisecond and one that specifies the sleep time to the nanosecond.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T071249Z" creationid="Admin" creationdate="20170622T071249Z">
        <seg>提供了两个重载的&lt;c0&gt; sleep &lt;/c0&gt;方法：一个指定睡眠时间为毫秒，一个指定睡眠时间为纳秒。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typically, variables that refer to executor objects are declared as one of these three interface types, not with an executor class type.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T030648Z" creationid="Admin" creationdate="20170630T030648Z">
        <seg>通常来说，指向 executor 对象的变量应被声明为以上三种接口之一，而不是具体的实现类。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Under different circumstances it might be Thread B's result that gets lost, or there could be no error at all.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T091205Z" creationid="Admin" creationdate="20170622T091205Z">
        <seg>在不同的系统环境中，有可能是 B 线程的结果丢失了，或者是根本就不会出现错误。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unfortunately, this rule does not account for the possibility that two friends might bow to each other at the same time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T074812Z" creationid="Admin" creationdate="20170623T074812Z">
        <seg>不幸的是，这条规则并没有考虑这种可能性：两个朋友同时向对方鞠躬。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike synchronized methods, synchronized statements must specify the object that provides the intrinsic lock:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T064504Z" creationid="Admin" creationdate="20170623T064504Z">
        <seg>与同步方法不同，同步语名块必须指定提供内在锁的对象：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use this idiom with extreme care.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T070056Z" creationid="Admin" creationdate="20170623T070056Z">
        <seg>采用这种方式时需要特别的小心。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using &lt;c0&gt;volatile&lt;/c0&gt; variables reduces the risk of memory consistency errors, because any write to a &lt;c1&gt;volatile&lt;/c1&gt; variable establishes a happens-before relationship with subsequent reads of that same variable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T073354Z" creationid="Admin" creationdate="20170623T073354Z">
        <seg>使用 &lt;c0&gt;volatile&lt;/c0&gt; 变量可以减少内存一致性错误的风险，因为任何对&lt;c1&gt;volatile&lt;/c1&gt; 变量的写操作都和后续对该变量的读操作建立了happens-before关系。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using simple atomic variable access is more efficient than accessing these variables through synchronized code, but requires more care by the programmer to avoid memory consistency errors.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T073646Z" creationid="Admin" creationdate="20170623T073646Z">
        <seg>使用简单的原子变量访问比通过同步代码来访问变量更高效，但是需要程序员的更多细心考虑，以避免内存一致性错误。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using worker threads minimizes the overhead due to thread creation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T063638Z" creationid="Admin" creationdate="20170630T063638Z">
        <seg>使用工作线程可以使创建线程的开销最小化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We have already seen that an increment expression, such as &lt;c0&gt;c++&lt;/c0&gt;, does not describe an atomic action.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T072159Z" creationid="Admin" creationdate="20170623T072159Z">
        <seg>通过前面的示例，我们已经发现了诸如  &lt;c0&gt;c++&lt;/c0&gt;这样的自增表达式并不属于原子操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We model this improvement by requiring that our &lt;c2&gt;Friend&lt;/c2&gt; objects must acquire locks for &lt;i3&gt;both&lt;/i3&gt; participants before proceeding with the bow.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T025327Z" creationid="Admin" creationdate="20170630T025009Z">
        <seg>我们通过要求&lt;c2&gt;Friend&lt;/c2&gt; 对象在双方鞠躬前，必须先获取&lt;i3&gt;双方&lt;/i3&gt; 的锁，来模拟这次改善。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We won't examine the specific steps the virtual machine takes  it is enough to know that the single expression &lt;c2&gt;c++&lt;/c2&gt; can be decomposed into three steps:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T085137Z" creationid="Admin" creationdate="20170622T085137Z">
        <seg>在这里，我们不深究虚拟机具体上上面的操作翻译成了什么样的步骤——只需要知道即使简单的&lt;c2&gt;c++&lt;/c2&gt; 这样的表达式也是会被翻译成三个步骤的：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We won't examine this package in detail, but instead will focus on its most basic interface, &lt;a2&gt;&lt;c3&gt;Lock&lt;/c3&gt;&lt;/a2&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T024227Z" creationid="Admin" creationdate="20170630T024227Z">
        <seg>我们不会详细地测试这个包，只重点关注最基本的接口&lt;a2&gt;&lt;c3&gt;Lock&lt;/c3&gt;&lt;/a2&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We'll examine some of these methods in the following sections.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T070101Z" creationid="Admin" creationdate="20170622T070101Z">
        <seg>我们将在以下部分中检验其中的一些方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We've already seen two actions that create happens-before relationships.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T092521Z" creationid="Admin" creationdate="20170622T092521Z">
        <seg>到目前为止，我们已经看到了两种建立这种 happens-before 的方式：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What if a thread goes a long time without invoking a method that throws &lt;c0&gt;InterruptedException&lt;/c0&gt;?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T074811Z" creationid="Admin" creationdate="20170622T074811Z">
        <seg>若线程长时间没有调用方法抛出 &lt;c0&gt;InterruptedException&lt;/c0&gt;？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What's more, it also means that when a thread reads a &lt;c3&gt;volatile&lt;/c3&gt; variable, it sees not just the latest change to the &lt;c4&gt;volatile&lt;/c4&gt;, but also the side effects of the code that led up the change.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T073617Z" creationid="Admin" creationdate="20170623T073617Z">
        <seg>更重要的是，这也意味着当一个线程读取一个 &lt;c3&gt;volatile&lt;/c3&gt;变量时，它不仅仅看到了对&lt;c4&gt;volatile&lt;/c4&gt;变量的最后一次修改，还看到了导致这种修改的代码带来的其他影响。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When &lt;c0&gt;Deadlock&lt;/c0&gt; runs, it's extremely likely that both threads will block when they attempt to invoke &lt;c1&gt;bowBack&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T075315Z" creationid="Admin" creationdate="20170623T075315Z">
        <seg>当&lt;c0&gt;Deadlock&lt;/c0&gt; 运行时，当两个线程尝试执行&lt;c1&gt;bowBack&lt;/c1&gt;时，它们非常有可能都被阻塞。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When &lt;c0&gt;wait&lt;/c0&gt; is invoked, the thread releases the lock and suspends execution.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T092056Z" creationid="Admin" creationdate="20170623T092056Z">
        <seg>当调用 &lt;c0&gt;wait&lt;/c0&gt; 方法时，线程释放锁并挂起。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a statement invokes &lt;c0&gt;Thread.start&lt;/c0&gt;, every statement that has a happens-before relationship with that statement also has a happens-before relationship with every statement executed by the new thread.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T092650Z" creationid="Admin" creationdate="20170622T092650Z">
        <seg>当一条语句中调用了 &lt;c0&gt;Thread.start&lt;/c0&gt;那么每一条和该语句已经建立了 happens-before 的语句都和新线程中的每一条语句有着这种 happens-before关系。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a thread checks for an interrupt by invoking the static method &lt;c2&gt;Thread.interrupted&lt;/c2&gt;, interrupt status is cleared.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T075219Z" creationid="Admin" creationdate="20170622T075219Z">
        <seg>当一个线程通过调用静态方法&lt;c2&gt;Thread.interrupted&lt;/c2&gt;检查中断，中断状态被清除。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a thread invokes &lt;c3&gt;d.wait&lt;/c3&gt;, it must own the intrinsic lock for &lt;c4&gt;d&lt;/c4&gt;  otherwise an error is thrown.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T091920Z" creationid="Admin" creationdate="20170623T091816Z">
        <seg>当一个线程调用 &lt;c3&gt;d.wait&lt;/c3&gt;方法时，它必须拥有 &lt;c4&gt;d&lt;/c4&gt;的内部锁——否则会抛出异常。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a thread invokes a synchronized method, it automatically acquires the intrinsic lock for that method's object and releases it when the method returns.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T063714Z" creationid="Admin" creationdate="20170623T063714Z">
        <seg>当一个线程调用一个同步方法的时，它会自动地获取该方法所属对象的内部锁，并在方法返回的时候释放该锁。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a thread releases an intrinsic lock, a happens-before relationship is established between that action and any subsequent acquisition of the same lock.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T063547Z" creationid="Admin" creationdate="20170623T063547Z">
        <seg>当一个线程释放了一个内部锁，那么就会建立起该动作和后续获取该锁之间的 happens-before 关系。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a thread terminates and causes a &lt;c0&gt;Thread.join&lt;/c0&gt; in another thread to return, then all the statements executed by the terminated thread have a happens-before relationship with all the statements following the successful join.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T092835Z" creationid="Admin" creationdate="20170622T092821Z">
        <seg>当一个线程终止了并导致另外的线程中调用&lt;c0&gt;Thread.join&lt;/c0&gt; 那么此时这个终止了的线程中执行了的所有语句都与随后的 join 语句随后的所有语句建立了这种 happens-before 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When one thread is executing a synchronized method for an object, all other threads that invoke synchronized methods for the same object block (suspend execution) until the first thread is done with the object.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T101502Z" creationid="Admin" creationdate="20170622T101502Z">
        <seg>当一个线程在执行一个对象的同步方式的时候，其他所有的调用该对象的同步方法的线程都会被挂起（暂停执行），直到第一个线程对该对象操作完毕。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Whether the extra effort is worthwhile depends on the size and complexity of the application.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T073709Z" creationid="Admin" creationdate="20170623T073709Z">
        <seg>这种额外的付出是否值得完全取决于应用程序的大小和复杂度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Which of these idioms should you use?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T063823Z" creationid="Admin" creationdate="20170622T063707Z">
        <seg>这些方式应该使用哪一个呢？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Why is this version of &lt;c0&gt;guardedJoy&lt;/c0&gt; synchronized?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T091726Z" creationid="Admin" creationdate="20170623T091726Z">
        <seg>为什么这个版本的&lt;c0&gt;guardedJoy&lt;/c0&gt; 是同步的？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With a limit on the number of the threads that can be created, the application will not be servicing HTTP requests as quickly as they come in, but it will be servicing them as quickly as the system can sustain.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T064340Z" creationid="Admin" creationdate="20170630T064340Z">
        <seg>如果限制 Web 服务器可以创建的线程数量，那么它就不必立即处理所有收到的请求，而是在有能力处理请求时才处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Without reentrant synchronization, synchronized code would have to take many additional precautions to avoid having a thread cause itself to block.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T071729Z" creationid="Admin" creationdate="20170623T071729Z">
        <seg>如果没有重入同步，在编写同步代码时需要额外的小心，以避免线程将自己阻塞。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Worker threads that run out of things to do can steal tasks from other threads that are still busy.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T065437Z" creationid="Admin" creationdate="20170630T065437Z">
        <seg>完成自己的工作而处于空闲的工作线程能够从其他仍然处于忙碌(busy)状态的工作线程处窃取等待执行的任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Would it help to change the parameters of the two invocations of &lt;c0&gt;Sleep&lt;/c0&gt;?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T074125Z" creationid="Admin" creationdate="20170630T074125Z">
        <seg>是否有助于更改&lt;c0&gt; Sleep &lt;/c0&gt;的两次调用的参数？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Would such an invocation make sense?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T073926Z" creationid="Admin" creationdate="20170630T073926Z">
        <seg>这样的调用是否有意义？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Wrap this code in a &lt;c0&gt;ForkJoinTask&lt;/c0&gt; subclass, typically using one of its more specialized types, either &lt;a1&gt;&lt;c2&gt;RecursiveTask&lt;/c2&gt;&lt;/a1&gt; (which can return a result) or &lt;a3&gt;&lt;c4&gt;RecursiveAction&lt;/c4&gt;&lt;/a3&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T070102Z" creationid="Admin" creationdate="20170630T070102Z">
        <seg>你需要将这段代码包裹在一个&lt;c0&gt;ForkJoinTask&lt;/c0&gt; 子类中，通常情况下会使用一种更为具体的的类型，&lt;a1&gt;&lt;c2&gt;RecursiveTask&lt;/c2&gt;&lt;/a1&gt; （它可以返回一个结果）或是 &lt;a3&gt;&lt;c4&gt;RecursiveAction&lt;/c4&gt;&lt;/a3&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can take advantage of concurrent processing on multiprocessor systems by implementing the algorithm using the fork/join framework.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T070615Z" creationid="Admin" creationdate="20170630T070615Z">
        <seg>如果使用 fork/join 框架来实现这个模糊算法，你就能够借助多处理器系统的并行处理能力。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You might be tempted to add the following line to your constructor:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T102457Z" creationid="Admin" creationdate="20170622T102457Z">
        <seg>我们可能会在构造函数中添加下列语名：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You might wonder what happens when a static synchronized method is invoked, since a static method is associated with a class, not an object.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T063808Z" creationid="Admin" creationdate="20170623T063808Z">
        <seg>您可能会想知道当调用静态同步方法时会发生什么，因为静态方法与一个类而不是一个对象相关联。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You must be absolutely sure that it really is safe to interleave access of the affected fields.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170623T070112Z" creationid="Admin" creationdate="20170623T070112Z">
        <seg>我们必须绝对确保相关字段的访问交错是完全安全的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Your code should look similar to the following pseudocode:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T065745Z" creationid="Admin" creationdate="20170630T065745Z">
        <seg>你的代码结构看起来应该与下面所示的伪代码类似：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>causes the current thread to pause execution until &lt;c0&gt;t&lt;/c0&gt;'s thread terminates.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170622T075724Z" creationid="Admin" creationdate="20170622T075724Z">
        <seg>它会导致当前线程暂停执行直到&lt;c0&gt;t&lt;/c0&gt;线程终止。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>do the work directly
else</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T065840Z" creationid="Admin" creationdate="20170630T065828Z">
        <seg>直接完成这个任务
else</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if (my portion of the work is small enough)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T065810Z" creationid="Admin" creationdate="20170630T065810Z">
        <seg>if (当前这个任务工作量足够小)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>invoke the two pieces and wait for the results</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T065913Z" creationid="Admin" creationdate="20170630T065913Z">
        <seg> 分别执行这两个子任务，并等待结果</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>split my work into two pieces</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T065848Z" creationid="Admin" creationdate="20170630T065848Z">
        <seg>将这个任务或这部分工作分解成两个部分</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>with</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Admin" changedate="20170630T031241Z" creationid="Admin" creationdate="20170630T031241Z">
        <seg>替换为</seg>
      </tuv>
    </tu>
<!-- Alternative translations -->
  </body>
</tmx>
